import cors from 'cors'
import fs from 'node:fs'
import https from 'node:https'
import crypto from 'node:crypto'
import { AsyncLocalStorage } from 'node:async_hooks'
import express from 'express'
import morgan from 'morgan'
import helmet from 'helmet'
import rateLimit from 'express-rate-limit'
import promClient from 'prom-client'
import webPush from 'web-push'
import { validateEnvOrExit } from './validateEnv'
import { DEFAULT_HISTORY_LIMIT, DEFAULT_SETTINGS } from './constants'
import { aiConfig } from './config'
import { globalSSEPool, TextStreamer, SSEConnection } from './streaming'
import {
  analyzeVisionRisk,
  shouldTriggerAlert,
  formatRiskReport,
  type VisionRiskAnalysis,
} from './visionRiskAnalyzer'
import {
  initializeAlertManager,
  dispatchVisionRiskAlert,
} from './alertManager'
import {
  initializeUltraManager,
  getUltraManager,
} from './ultraMode'
import { executeMcpTool, getMcpToolDefinitions, isMcpEnabled, isMcpTool } from './mcp'
import { invokeLocalMcpTool, listLocalMcpTools } from './mcpHandlers'
import { PROMPT_INJECTION_PATTERNS, enforceCatOnlyAnswer, buildPolicyMessage } from './policyGuards'
import { classifyPromptSafety } from './safetyClassifier'
// ðŸ”’ çŽ¯å¢ƒå˜é‡éªŒè¯ï¼ˆåœ¨ä»»ä½•å…¶ä»–æ“ä½œä¹‹å‰ï¼‰
// Environment variable validation (before any other operations)
validateEnvOrExit()
import {
  loadHistory,
  loadLatestSnapshot,
  loadLanguage,
  loadSettings as loadStoredSettings,
  loadCalibration,
  saveCalibration,
  saveLanguage,
  savePushSubscription,
  listPushSubscriptions,
  removePushSubscription,
  saveSettings as persistSettings,
  saveSnapshot as persistSnapshot,
  saveAutomationAlert,
  loadAutomationAlerts,
  listMemories,
  addMemory,
  updateMemory,
  removeMemory,
  listPinnedToolEvents,
  savePinnedToolEvent,
  removePinnedToolEvent,
  addNotificationFix,
  listNotificationFixes,
  listAlertRules,
  createAlertRule,
  updateAlertRule,
  removeAlertRule,
  listChatFavorites,
  saveChatFavorite,
  deleteChatFavorite,
  performDatabaseCleanup,
  getDatabaseStats,
  enqueueHardwareCommand,
  claimNextHardwareCommand,
  completeHardwareCommand,
  resetStaleHardwareCommands,
  getHardwareCommandById,
  listCareTasks,
  createCareTask,
  updateCareTaskStatus,
  removeCareTask,
  listCats,
  getCat,
  upsertCat,
  removeCat,
  listCarePlugins,
  upsertCarePlugin,
  updateCarePluginEnabled,
  deleteCarePlugin,
  loadDashboardLayoutPreference,
  saveDashboardLayoutPreference,
  saveCalibrationHistory,
  getCalibrationHistory,
  getCalibrationHistoryById,
  countCalibrationHistory,
} from './db'
import type { StoredPushSubscription, HardwareCommandRecord, MemoryEntryRecord, CalibrationHistoryRecord } from './db'
import { maybeStartSerialBridge, type SerialBridgeConnection } from './serialBridge'
import {
  generateChatContent,
  getChatMetrics,
  buildSystemPrompt,
  analyzeImageWithQwen,
  type ReasoningEffort,
  applyPersonaSignature,
} from './ai'
import {
  configureCameraFromEnv,
  fetchCameraSnapshotBuffer,
  getCameraRuntime,
  ingestCameraEvent,
  pollCameraStatus,
  updateCameraRuntimeFromReading,
} from './camera'
import {
  buildSnapshot,
  deriveStatus,
  isSmartHomeReading,
  isSmartHomeSettings,
} from './utils'
import { buildProfessionalCareReport } from './reports'
import { synthesizeSpeech, listVoicePresets, type SynthesizeSpeechOptions } from './speech'
import { deriveCareInsights, deriveBehaviorForecast, suggestCareTasks, summarizeCalibrationAdjustment } from './analytics'
import { ensureBehaviorProfile, refreshBehaviorProfile } from './behaviorLearning'
import {
  validateImageUpload,
  validateDocumentUpload,
  VALIDATION_LIMITS,
  ALLOWED_IMAGE_MIME_TYPES,
} from './validators'
import { retrieveKnowledgeArticles, listKnowledgeArticles, buildKnowledgePrompt } from './knowledge'
import * as knowledgeExtractor from './knowledgeExtractor.js'
import * as proactiveAssistant from './proactiveAssistant.js'
import * as fileHandler from './fileHandler.js'
import { analyzePDF, generatePDFSummary } from './pdfParser.js'
import { analyzeDocumentAttachment } from './documentParser.js'
import { analyzeAudioWithAI, generateAudioSummary } from './audioAnalyzer.js'
import { analyzeVideoWithAI, generateVideoSummary } from './videoProcessor.js'
import {
  attachAuthContext,
  attachDevSession,
  authenticateUser,
  getPublicUser,
  issueSession,
  invalidateSession,
  requireAuthenticated,
  requireDeveloper,
} from './auth'
import {
  validateAlertRule,
  validateMemory,
  validateTask,
  validatePlugin,
  validateQueryString,
  validateChatFavorite,
  sanitizeString,
} from './validators'
import type {
  EquipmentTestResponse,
  LanguageCode,
  SmartHomeReading,
  SmartHomeSettings,
  SmartHomeSnapshot,
  CalibrationProfile,
  AutomationAlert,
  AlertMessageKey,
  ChatTool,
  ChatToolCall,
  ToolExecutionLog,
  MemoryEntry,
  MemoryType,
  NotificationFixLog,
  AlertRule,
  ChatFavorite,
  TextToSpeechResponsePayload,
  CareTask,
  CareTaskStatus,
  CareInsightCategory,
  CatProfile,
  AudioStatus,
  VisionStatus,
  VisionInference,
} from './types'

const app = express()
app.set('trust proxy', 1)

function sanitizeSystemPrompt(prompt: string): string {
  if (!prompt || typeof prompt !== 'string') {
    return ''
  }
  return prompt
    .split('\n')
    .map((line) => line.replace(/\s+/g, ' ').trim())
    .filter((line) => line.length > 0)
    .join('\n')
}

const TOOL_EVENT_HISTORY: Array<ToolExecutionLog & { timestamp: string }> = []
const MAX_TOOL_EVENTS = 20
const MEMORY_TYPES: MemoryType[] = ['note', 'conversation', 'setting']
const PINNED_TOOL_EVENTS = new Map<
  string,
  ToolExecutionLog & { timestamp: string; pinnedAt: string }
>()
const MAX_PINNED_TOOL_EVENTS = 50
const CARE_TASK_CATEGORIES: ReadonlySet<CareInsightCategory | 'general'> = new Set([
  'environment',
  'hydration',
  'nutrition',
  'behavior',
  'wellness',
  'safety',
  'maintenance',
  'general',
])

type CatPayload = {
  name: string
  avatarUrl?: string | null
  breed?: string | null
  birthdate?: string | null
  weightKg?: number | null
  notes?: string | null
  tags?: string[] | null
}

function validateCatPayload(data: unknown): { ok: true; value: CatPayload } | { ok: false; message: string } {
  if (!data || typeof data !== 'object') {
    return { ok: false, message: 'invalid-payload' }
  }

  const record = data as Record<string, unknown>
  const rawName = typeof record.name === 'string' ? record.name.trim() : ''
  if (!rawName) {
    return { ok: false, message: 'name-required' }
  }

  const payload: CatPayload = {
    name: rawName.slice(0, VALIDATION_LIMITS.MAX_SHORT_TEXT_LENGTH),
  }

  if (typeof record.avatarUrl === 'string') {
    payload.avatarUrl = record.avatarUrl.trim() || null
  }
  if (typeof record.breed === 'string') {
    payload.breed = record.breed.trim() || null
  }
  if (typeof record.birthdate === 'string') {
    payload.birthdate = record.birthdate.trim() || null
  }
  if (typeof record.notes === 'string') {
    payload.notes = record.notes.trim() || null
  }
  if (typeof record.weightKg === 'number' && Number.isFinite(record.weightKg)) {
    payload.weightKg = record.weightKg
  }
  if (Array.isArray(record.tags)) {
    const tags = record.tags
      .map((tag) => (typeof tag === 'string' ? tag.trim() : ''))
      .filter((tag) => tag.length > 0 && tag.length <= VALIDATION_LIMITS.MAX_SHORT_TEXT_LENGTH)
    payload.tags = tags.length > 0 ? tags : null
  }

  return { ok: true, value: payload }
}
const CARE_TASK_STATUS_VALUES: ReadonlySet<CareTaskStatus> = new Set(['pending', 'completed', 'dismissed'])
const SEARCH_PROXY_URL = process.env.SMARTCAT_SEARCH_PROXY_URL?.trim() || 'http://127.0.0.1:5858/search'
const SEARCH_PROXY_TIMEOUT_MS = (() => {
  const raw = Number.parseInt(process.env.SMARTCAT_SEARCH_TIMEOUT_MS ?? '8000', 10)
  if (!Number.isFinite(raw) || raw <= 0) return 8000
  return Math.max(2000, Math.min(raw, 20000))
})()
// ðŸ”§ FIX: Include all search-related tools (web search + MCP knowledge base search)
const SEARCH_TOOL_NAMES = new Set(['searchWeb', 'mcp.searchKnowledgeBase', 'mcp.browser.search'])
const MAX_SEARCH_CALLS_PER_REQUEST = 1

const SYSTEM_MEMORIES: Array<{ type: MemoryType; content: string; source: string }> = [
  {
    type: 'note',
    source: 'system',
    content:
      'Smart Cat Home AI åŠŸèƒ½ï¼š1) ç›£æ¸¬æ„Ÿæ¸¬è³‡æ–™ä¸¦æ•´ç†å¿«é€Ÿæ‘˜è¦ï¼›2) ä¾ç…§å®‰å…¨ç¯„åœå‘¼å« updateSettings èª¿æ•´ Autosetï¼ˆæº«åº¦ 16-36Â°Cã€æ¿•åº¦ 30%-70% ç­‰ï¼‰ï¼›3) é€éŽ updateCalibration æ›´æ–° FSRã€è¶…éŸ³æ³¢æˆ–äº®åº¦æ ¡æ­£ï¼›4) å”åŠ©ç´€éŒ„/æŸ¥è©¢èŠå¤©å‚™å¿˜èˆ‡æ”¶è—ï¼›5) åœ¨æ„Ÿæ¸¬é¢¨éšªæˆ–è‡ªè¨‚è­¦å ±è§¸ç™¼æ™‚æä¾›å³æ™‚å»ºè­°èˆ‡æé†’ã€‚',
  },
  {
    type: 'note',
    source: 'system',
    content:
      'ç•¶ä½¿ç”¨è€…è©¢å•ã€Œä½ èƒ½åšä»€éº¼ / what can you doã€æ™‚ï¼Œè«‹ä»¥å‹å–„èªžæ°£åˆ—å‡ºä¸»è¦èƒ½åŠ›ã€å¯åŸ·è¡Œçš„å·¥å…·ï¼Œä»¥åŠè‡³å°‘ä¸‰å€‹ç¯„ä¾‹æŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼šã€ŒæŠŠæ¿•åº¦èª¿æˆ 55%ã€ã€ã€Œå¹«æˆ‘æ›´æ–°æ°´ç¢—æ ¡æ­£ 2.3 å…¬åˆ†ã€ã€ã€Œåˆ†æžé€™å¼µç¡è¦ºç…§ç‰‡ã€ç­‰ï¼Œä¸¦é‚€è«‹å°æ–¹ç¹¼çºŒæå•ã€‚',
  },
]

function seedSystemMemories() {
  try {
    const existing = new Set(
      listMemories(500)
        .filter((entry) => entry.source === 'system')
        .map((entry) => entry.content.trim()),
    )
    for (const memory of SYSTEM_MEMORIES) {
      if (!existing.has(memory.content.trim())) {
        addMemory(memory)
      }
    }
  } catch (error) {
    console.warn('[memories] Failed to seed system memories', error)
  }
}

seedSystemMemories()

for (const event of listPinnedToolEvents()) {
  PINNED_TOOL_EVENTS.set(event.timestamp, {
    tool: event.tool,
    success: event.success,
    message: event.message,
    args: event.args,
    durationMs: event.durationMs,
    output: event.output,
    timestamp: event.timestamp,
    pinnedAt: event.pinnedAt,
  })
}

let alertRulesCache: AlertRule[] = listAlertRules()

function refreshAlertRules() {
  alertRulesCache = listAlertRules()
}

function recordToolEvent(log: ToolExecutionLog) {
  const entry: ToolExecutionLog & { timestamp: string } = {
    tool: log.tool,
    success: log.success,
    message: log.message,
    timestamp: new Date().toISOString(),
  }

  if (typeof log.args !== 'undefined') {
    entry.args = log.args
  }
  if (typeof log.durationMs === 'number') {
    entry.durationMs = log.durationMs
  }
  if (typeof log.output === 'string') {
    entry.output = log.output
  }
  TOOL_EVENT_HISTORY.unshift(entry)
  if (TOOL_EVENT_HISTORY.length > MAX_TOOL_EVENTS) {
    TOOL_EVENT_HISTORY.length = MAX_TOOL_EVENTS
  }
  const pinned = PINNED_TOOL_EVENTS.get(entry.timestamp)
  if (pinned) {
    const updated: ToolExecutionLog & { timestamp: string; pinnedAt: string } = {
      tool: entry.tool,
      success: entry.success,
      message: entry.message,
      timestamp: entry.timestamp,
      pinnedAt: pinned.pinnedAt,
    }
    if (typeof entry.args !== 'undefined') {
      updated.args = entry.args
    }
    if (typeof entry.durationMs === 'number') {
      updated.durationMs = entry.durationMs
    }
    if (typeof entry.output === 'string') {
      updated.output = entry.output
    }
    PINNED_TOOL_EVENTS.set(entry.timestamp, updated)
    savePinnedToolEvent(updated)
  }
}

async function summarizeDocumentAttachmentBeforeChat(params: {
  attachment: DocumentAttachment
  requestedCatId: string
  userId: string
  toolEvents: ToolExecutionLog[]
  connection?: SSEConnection | null
}): Promise<string> {
  const { attachment, requestedCatId, userId, toolEvents, connection } = params
  const startAt = Date.now()
  const filename = attachment.filename ?? `document-${Date.now()}`
  const { analysis } = await analyzeDocumentAttachment({
    dataUrl: attachment.dataUrl,
    mimeType: attachment.mimeType,
    filename,
    userId,
    catId: requestedCatId,
  })

  const log: ToolExecutionLog = {
    tool: 'analyzeDocument',
    success: true,
    message: `Document analyzed: ${analysis.filename}`,
    args: { filename: analysis.filename, type: attachment.type },
    durationMs: Date.now() - startAt,
    output: analysis.summary,
  }

  toolEvents.push(log)
  recordToolEvent(log)
  connection?.sendTool(log.tool, log.args ?? undefined, log)

  return analysis.summary
}

function getRecentToolEvents(limit = 5) {
  if (limit <= 0) return []
  const pinned = new Set(PINNED_TOOL_EVENTS.keys())
  const results: Array<ToolExecutionLog & { timestamp: string }> = []
  for (const event of TOOL_EVENT_HISTORY) {
    if (pinned.has(event.timestamp)) {
      continue
    }
    results.push(event)
    if (results.length >= limit) break
  }
  return results
}

function getPinnedToolEvents() {
  return [...PINNED_TOOL_EVENTS.values()].sort((a, b) => b.pinnedAt.localeCompare(a.pinnedAt))
}

function enforcePinnedLimit() {
  if (PINNED_TOOL_EVENTS.size <= MAX_PINNED_TOOL_EVENTS) return
  const orderedOldestFirst = [...PINNED_TOOL_EVENTS.values()].sort((a, b) => a.pinnedAt.localeCompare(b.pinnedAt))
  while (orderedOldestFirst.length > MAX_PINNED_TOOL_EVENTS) {
    const removed = orderedOldestFirst.shift()
    if (!removed) break
    PINNED_TOOL_EVENTS.delete(removed.timestamp)
    removePinnedToolEvent(removed.timestamp)
  }
}

function constantTimeEqual(expected: string, received: string): boolean {
  const expectedBuf = Buffer.from(expected, 'utf8')
  const receivedBuf = Buffer.from(received, 'utf8')
  if (expectedBuf.length !== receivedBuf.length) {
    return false
  }
  return crypto.timingSafeEqual(expectedBuf, receivedBuf)
}

function safeErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message
  }
  if (typeof error === 'string') {
    return error
  }
  return 'unknown-error'
}

function ensureHardwareAuthorized(req: express.Request, res: express.Response): boolean {
  if (!HARDWARE_API_KEY) {
    return true
  }

  const authHeader = req.headers.authorization ?? ''
  const normalized = authHeader.trim()
  if (!normalized.toLowerCase().startsWith('bearer ')) {
    res.status(401).json({ ok: false, message: 'hardware-unauthorized' })
    return false
  }

  const token = normalized.slice(7).trim()
  if (!token || !constantTimeEqual(HARDWARE_API_KEY, token)) {
    res.status(401).json({ ok: false, message: 'hardware-unauthorized' })
    return false
  }

  return true
}

function ensureAdminAuthorized(req: express.Request, res: express.Response): boolean {
  if (req.authUser?.role === 'developer') {
    return true
  }
  if (!ADMIN_API_KEY) {
    return true
  }

  const headerValue =
    typeof req.headers['x-smartcat-admin'] === 'string'
      ? req.headers['x-smartcat-admin']
      : Array.isArray(req.headers['x-smartcat-admin'])
        ? req.headers['x-smartcat-admin'][0]
        : typeof req.headers.authorization === 'string'
          ? req.headers.authorization
          : undefined

  if (!headerValue) {
    res.status(401).json({ ok: false, message: 'admin-unauthorized' })
    return false
  }

  const token = headerValue.toLowerCase().startsWith('bearer ')
    ? headerValue.slice(7).trim()
    : headerValue.trim()

  if (!token || !constantTimeEqual(ADMIN_API_KEY, token)) {
    res.status(401).json({ ok: false, message: 'admin-unauthorized' })
    return false
  }

  return true
}

function ensureDeveloperOrAdmin(req: express.Request, res: express.Response): boolean {
  if (req.authUser && req.authUser.role === 'developer') {
    return true
  }
  return ensureAdminAuthorized(req, res)
}

function serializeHardwareCommand(command: HardwareCommandRecord) {
  return {
    id: command.id,
    type: command.type,
    payload: typeof command.payload === 'undefined' ? null : command.payload,
    status: command.status,
    createdAt: command.createdAt,
    claimedAt: command.claimedAt ?? null,
    completedAt: command.completedAt ?? null,
    resultMessage: command.resultMessage ?? null,
  }
}

function recordNotificationFix(step: NotificationFixLog['step'], success: boolean, message?: string) {
  const base: NotificationFixLog = {
    id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
    step,
    success,
    timestamp: new Date().toISOString(),
  }
  const log: NotificationFixLog = message ? { ...base, message } : base
  addNotificationFix(log)
  return log
}

function isMemoryType(value: unknown): value is MemoryType {
  return typeof value === 'string' && (MEMORY_TYPES as readonly string[]).includes(value)
}

function isChatTool(value: unknown): value is ChatTool {
  return (
    value === 'updateSettings' ||
    value === 'updateCalibration' ||
    value === 'saveMemory' ||
    value === 'createCareTask' ||
    value === 'switchToProModel' ||
    value === 'searchWeb' ||
    value === 'playAudioPattern' ||
    value === 'stopAudioPlayback' ||
    value === 'refreshCameraStatus'
  )
}

function normalizeToolEventPayload(payload: unknown): (ToolExecutionLog & { timestamp: string }) | null {
  if (!payload || typeof payload !== 'object') return null
  const record = payload as Record<string, unknown>
  const { timestamp, tool, success, message } = record
  if (typeof timestamp !== 'string' || timestamp.length === 0) return null
  if (!isChatTool(tool)) return null
  if (typeof success !== 'boolean') return null
  if (typeof message !== 'string' || message.length === 0) return null

  const normalized: ToolExecutionLog & { timestamp: string } = {
    timestamp,
    tool,
    success,
    message,
  }

  if ('args' in record) {
    normalized.args = record.args
  }

  if (typeof record.durationMs === 'number' && Number.isFinite(record.durationMs)) {
    normalized.durationMs = record.durationMs
  }

  if (typeof record.output === 'string') {
    normalized.output = record.output
  }

  return normalized
}

const STOP_WORDS = new Set<string>([
  'the',
  'and',
  'with',
  'that',
  'this',
  'from',
  'into',
  'your',
  'have',
  'will',
  'just',
  'about',
  'when',
  'where',
  'what',
  'which',
  'then',
  'them',
  'they',
  'their',
  'been',
  'were',
  'than',
  'only',
  'also',
  'maybe',
  'should',
  'could',
  'would',
  'there',
  'here',
  'very',
  'more',
  'less',
  'some',
  'such',
  'even',
  'onto',
  'upon',
  'because',
  'while',
  'after',
  'before',
  'since',
  'please',
  'thanks',
  'thank',
  'https',
  'http',
  'www',
  'com',
  'ä½¿ç”¨',
  'ä»¥åŠ',
  'æˆ‘å€‘',
  'ç¾åœ¨',
  'éœ€è¦',
  'å¦‚æžœ',
])

function normalizeText(text: string) {
  return text
    .normalize('NFKD')
    .toLowerCase()
    .replace(/[\u0300-\u036f]/g, '')
}

function buildNGramVector(text: string, size = 3) {
  const normalized = normalizeText(text).replace(/\s+/g, ' ')
  const source = normalized.trim().length > 0 ? normalized.trim() : normalized
  const vector = new Map<string, number>()
  if (source.length === 0) return vector

  const padded = source.length < size ? source.padEnd(size, ' ') : source
  for (let index = 0; index <= padded.length - size; index += 1) {
    const gram = padded.slice(index, index + size)
    vector.set(gram, (vector.get(gram) ?? 0) + 1)
  }
  return vector
}

function tokenizeText(text: string) {
  const normalized = normalizeText(text)
  const tokens: string[] = []

  const wordMatches = normalized.match(/\p{L}[\p{L}\p{N}_-]*/gu)
  if (wordMatches) {
    for (const raw of wordMatches) {
      const token = raw.replace(/[_-]+/g, '')
      if (token.length >= 2 && !STOP_WORDS.has(token)) {
        tokens.push(token)
      }
    }
  }

  if (tokens.length === 0) {
    const numericMatches = normalized.match(/\d+(?:\.\d+)?/g)
    if (numericMatches) {
      tokens.push(...numericMatches)
    }
  }

  if (tokens.length === 0) {
    const cjkMatches = normalized.match(/[\p{Script=Han}]/gu)
    if (cjkMatches) {
      tokens.push(...cjkMatches)
    }
  }

  return tokens.slice(0, 50)
}

function buildTermFrequency(tokens: string[]) {
  const map = new Map<string, number>()
  for (const token of tokens) {
    map.set(token, (map.get(token) ?? 0) + 1)
  }
  return map
}

function computeVector(
  termFrequency: Map<string, number>,
  documentFrequency: Map<string, number>,
  totalDocs: number,
) {
  const vector = new Map<string, number>()
  for (const [token, count] of termFrequency) {
    const tf = 1 + Math.log(count)
    const df = documentFrequency.get(token) ?? 0
    const idf = Math.log(1 + totalDocs / (1 + df))
    vector.set(token, tf * idf)
  }
  return vector
}

function vectorMagnitude(vector: Map<string, number>) {
  let sum = 0
  for (const value of vector.values()) {
    sum += value * value
  }
  return Math.sqrt(sum)
}

function cosineSimilarity(
  vectorA: Map<string, number>,
  vectorB: Map<string, number>,
  magnitudeB?: number,
) {
  if (vectorA.size === 0 || vectorB.size === 0) return 0
  const magnitudeA = vectorMagnitude(vectorA)
  const magB = typeof magnitudeB === 'number' ? magnitudeB : vectorMagnitude(vectorB)
  if (magnitudeA === 0 || magB === 0) return 0
  let dot = 0
  for (const [token, value] of vectorA) {
    const other = vectorB.get(token)
    if (typeof other === 'number') {
      dot += value * other
    }
  }
  if (dot === 0) return 0
  return dot / (magnitudeA * magB)
}

function daysSince(timestamp: string) {
  const createdAt = new Date(timestamp)
  if (Number.isNaN(createdAt.getTime())) return Number.POSITIVE_INFINITY
  const diffMs = Date.now() - createdAt.getTime()
  return diffMs > 0 ? diffMs / (1000 * 60 * 60 * 24) : 0
}

const ALERT_RULE_METRIC_LABELS: Record<AlertRule['metric'], string> = {
  temperatureC: 'temperature (Â°C)',
  humidityPercent: 'humidity (%)',
  waterLevelPercent: 'water level (%)',
  ambientLightPercent: 'ambient light (%)',
  waterIntakeMl: 'water intake (ml)',
  airQualityIndex: 'air quality index',
  catWeightKg: 'cat weight (kg)',
  lastFeedingMinutesAgo: 'minutes since feeding',
}

const ALERT_RULE_METRICS = new Set<AlertRule['metric']>(Object.keys(ALERT_RULE_METRIC_LABELS) as AlertRule['metric'][])
const ALERT_RULE_COMPARISONS = new Set<AlertRule['comparison']>(['above', 'below'])
const ALERT_RULE_SEVERITIES = new Set<AlertRule['severity']>(['info', 'warning', 'critical'])
const CHAT_ROLES = new Set<ChatFavorite['role']>(['user', 'assistant', 'system'])

type MemoryFeatureCacheEntry = {
  signature: string
  tokenSet: Set<string>
  termFrequency: Map<string, number>
  ngramVector: Map<string, number>
  lowerContent: string
}

const memoryFeatureCache = new Map<number, MemoryFeatureCacheEntry>()

function buildMemorySignature(entry: MemoryEntryRecord): string {
  return `${entry.content}||${entry.source}||${entry.type}||${entry.createdAt}`
}

function getMemoryFeatures(entry: MemoryEntryRecord): MemoryFeatureCacheEntry {
  const existing = memoryFeatureCache.get(entry.id)
  const signature = buildMemorySignature(entry)
  if (existing && existing.signature === signature) {
    return existing
  }

  const combined = `${entry.content} ${entry.source}`
  const tokens = tokenizeText(combined)
  const features: MemoryFeatureCacheEntry = {
    signature,
    tokenSet: new Set(tokens),
    termFrequency: buildTermFrequency(tokens),
    ngramVector: buildNGramVector(combined),
    lowerContent: entry.content.toLowerCase(),
  }

  memoryFeatureCache.set(entry.id, features)
  return features
}

function getMetricValue(reading: SmartHomeReading, metric: AlertRule['metric']): number | undefined {
  const record = reading as unknown as Record<string, unknown>
  const value = record[metric]
  if (typeof value === 'number' && Number.isFinite(value)) {
    return value
  }
  return undefined
}

function evaluateAlertRules(reading: SmartHomeReading) {
  for (const rule of alertRulesCache) {
    if (!rule.enabled) continue
    const value = getMetricValue(reading, rule.metric)
    if (typeof value !== 'number') continue
    const triggered = rule.comparison === 'above' ? value > rule.threshold : value < rule.threshold
    if (!triggered) continue
    const metricLabel = ALERT_RULE_METRIC_LABELS[rule.metric] ?? rule.metric
    const message = rule.message
      ? rule.message
      : rule.comparison === 'above'
        ? `Custom alert: ${metricLabel} (${value.toFixed(1)}) exceeded ${rule.threshold}.`
        : `Custom alert: ${metricLabel} (${value.toFixed(1)}) fell below ${rule.threshold}.`
    pushAlert({ message: `${message} [rule-${rule.id}]`, severity: rule.severity })
  }
}

// ðŸ§  Memory Search Performance Optimization
// Cache document frequency globally to avoid O(nÂ²) recalculation on every search
interface MemorySearchCache {
  documentFrequency: Map<string, number>
  totalDocs: number
  lastUpdated: string
}

let memorySearchCache: MemorySearchCache | null = null
let isRebuildingCache = false // Guard against re-entry

function rebuildMemorySearchCache() {
  if (isRebuildingCache) {
    console.warn('[memory] âš ï¸  Cache rebuild already in progress, skipping')
    return
  }

  isRebuildingCache = true
  try {
    const MAX_CANDIDATES = 200
    const rawEntries = listMemories(MAX_CANDIDATES).filter((entry) => isMemoryType(entry.type))

    const documentFrequency = new Map<string, number>()
    for (const entry of rawEntries) {
      const features = getMemoryFeatures(entry)
      for (const token of features.tokenSet) {
        documentFrequency.set(token, (documentFrequency.get(token) ?? 0) + 1)
      }
    }

    memorySearchCache = {
      documentFrequency,
      totalDocs: rawEntries.length,
      lastUpdated: new Date().toISOString(),
    }

    console.log(`[memory] search cache rebuilt: ${rawEntries.length} documents, ${documentFrequency.size} unique tokens`)
  } finally {
    isRebuildingCache = false
  }
}

// Rebuild cache every 5 minutes
setInterval(() => {
  rebuildMemorySearchCache()
}, 5 * 60 * 1000)

function loadRelevantMemories(question: string, limit = 5): MemoryEntry[] {
  const MAX_CANDIDATES = 200
  const rawEntries = listMemories(MAX_CANDIDATES).filter((entry) => isMemoryType(entry.type))
  if (rawEntries.length === 0) {
    return []
  }

  // Use cached document frequency or rebuild if needed
  if (!memorySearchCache || memorySearchCache.totalDocs !== rawEntries.length) {
    console.log(`[memory] ðŸ”„ Cache rebuild triggered: cached=${memorySearchCache?.totalDocs ?? 'null'}, actual=${rawEntries.length}`)
    rebuildMemorySearchCache()
  }

  const documentFrequency = memorySearchCache!.documentFrequency
  const totalDocs = memorySearchCache!.totalDocs

  const prepared = rawEntries.map((entry) => {
    const memory = {
      id: entry.id,
      type: entry.type as MemoryType,
      content: entry.content,
      source: entry.source,
      createdAt: entry.createdAt,
    }
    const features = getMemoryFeatures(entry)
    return { memory, features }
  })

  const questionTokens = tokenizeText(question)
  const questionNGramVector = buildNGramVector(question)
  const questionNGramMagnitude = vectorMagnitude(questionNGramVector)

  if (questionTokens.length === 0) {
    const ngramCandidates =
      questionNGramVector.size > 0
        ? prepared
            .map((item, index) => ({
              memory: item.memory,
              score: cosineSimilarity(item.features.ngramVector, questionNGramVector, questionNGramMagnitude),
              index,
            }))
            .filter((item) => item.score > 0)
            .sort((a, b) => (b.score !== a.score ? b.score - a.score : a.index - b.index))
            .slice(0, limit)
            .map((item) => item.memory)
        : []

    if (ngramCandidates.length > 0) {
      return ngramCandidates
    }

    return prepared
      .slice()
      .sort(
        (a, b) =>
          new Date(b.memory.createdAt).getTime() - new Date(a.memory.createdAt).getTime(),
      )
      .slice(0, limit)
      .map((entry) => entry.memory)
  }

  const queryTf = buildTermFrequency(questionTokens)
  const queryVector = computeVector(queryTf, documentFrequency, totalDocs)
  const queryMagnitude = vectorMagnitude(queryVector)

  const scored = prepared
    .map((item, index) => {
      const vector = computeVector(item.features.termFrequency, documentFrequency, totalDocs)
      const similarity = cosineSimilarity(vector, queryVector, queryMagnitude)
      const typeBoost = (() => {
        switch (item.memory.type) {
          case 'setting':
            return 1.3
          case 'note':
            return 1.2
          case 'conversation':
            return 1.1
          default:
            return 1
        }
      })()
      const recencyBoost = (() => {
        const ageDays = daysSince(item.memory.createdAt)
        if (!Number.isFinite(ageDays)) return 1
        if (ageDays <= 3) return 1.4
        if (ageDays <= 14) return 1.2
        if (ageDays <= 60) return 1.05
        return 1
      })()
      const keywordBonus = questionTokens.reduce((total, token) => {
        return item.features.lowerContent.includes(token) ? total + 0.05 : total
      }, 0)
      const ngramSimilarity =
        questionNGramMagnitude > 0
          ? cosineSimilarity(item.features.ngramVector, questionNGramVector, questionNGramMagnitude)
          : 0
      const finalScore = similarity * typeBoost * recencyBoost + keywordBonus + ngramSimilarity * 0.4
      return { memory: item.memory, score: finalScore, index }
    })
    .filter((item) => item.score > 0)
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score
      return a.index - b.index
    })
    .slice(0, limit)
    .map((item) => item.memory)

  if (scored.length > 0) {
    return scored
  }

  if (questionNGramVector.size > 0) {
    const fallbackByNGram = prepared
      .map((item, index) => ({
        memory: item.memory,
        score: cosineSimilarity(item.features.ngramVector, questionNGramVector, questionNGramMagnitude),
        index,
      }))
      .filter((item) => item.score > 0)
      .sort((a, b) => (b.score !== a.score ? b.score - a.score : a.index - b.index))
      .slice(0, limit)
      .map((item) => item.memory)

    if (fallbackByNGram.length > 0) {
      return fallbackByNGram
    }
  }

  return prepared
    .slice()
    .sort(
      (a, b) =>
        new Date(b.memory.createdAt).getTime() - new Date(a.memory.createdAt).getTime(),
    )
    .slice(0, limit)
    .map((entry) => entry.memory)
}

function findLastMessageByRole<T extends { role?: string }>(
  messages: T[],
  role: 'user' | 'assistant' | 'system',
): T | null {
  for (let index = messages.length - 1; index >= 0; index -= 1) {
    const candidate = messages[index]
    if (candidate && candidate.role === role) {
      return candidate
    }
  }
  return null
}

function getMemoryKeywordStats(limit = 20) {
  const entries = listMemories(200)
  const counts = new Map<string, number>()

  for (const entry of entries) {
    const tokens = tokenizeText(entry.content)
    const typeWeight = entry.type === 'setting' ? 1.35 : entry.type === 'note' ? 1.2 : 1.05
    for (const token of tokens) {
      counts.set(token, (counts.get(token) ?? 0) + typeWeight)
    }
  }

  const sorted = Array.from(counts.entries())
    .filter(([, score]) => score > 0)
    .sort((a, b) => b[1] - a[1])
    .slice(0, limit)
    .map(([keyword, score]) => ({ keyword, score }))

  return sorted
}

function buildDiagnosticReport(): string {
  const now = new Date().toISOString()
  const chatMetrics = getChatMetrics()
  const recentToolEvents = getRecentToolEvents(5)
  const pinned = getPinnedToolEvents()
  const fixes = listNotificationFixes(10)
  const favorites = listChatFavorites()
  const keywordStats = getMemoryKeywordStats(10)
  const lines: string[] = []

  lines.push('Smart Cat Home Diagnostic Report')
  lines.push(`Generated at: ${now}`)
  lines.push('')

  if (latestSnapshot) {
    lines.push('Latest Snapshot:')
    lines.push(`  Timestamp: ${latestSnapshot.reading.timestamp}`)
    lines.push(`  Temperature: ${latestSnapshot.reading.temperatureC} Â°C`)
    lines.push(`  Humidity: ${latestSnapshot.reading.humidityPercent}%`)
    if (typeof latestSnapshot.reading.waterLevelPercent === 'number') {
      lines.push(`  Water level: ${latestSnapshot.reading.waterLevelPercent}%`)
    }
    lines.push(`  Air Quality Index: ${latestSnapshot.reading.airQualityIndex}`)
  } else {
    lines.push('Latest Snapshot: none')
  }

  lines.push('')
  lines.push('AI Inference Metrics:')
  lines.push(`  Provider: ${chatMetrics.provider ?? 'unknown'}`)
  lines.push(`  Source: ${chatMetrics.source ?? 'unknown'}`)
  lines.push(`  Duration (ms): ${chatMetrics.durationMs ?? 'n/a'}`)
  lines.push(`  Updated: ${chatMetrics.updatedAt ?? 'n/a'}`)
  if (chatMetrics.error) {
    lines.push(`  Error: ${chatMetrics.error}`)
  }

  lines.push('')
  lines.push('Custom Alert Rules:')
  if (alertRulesCache.length === 0) {
    lines.push('  (none)')
  } else {
    for (const rule of alertRulesCache) {
      const status = rule.enabled ? 'enabled' : 'disabled'
      lines.push(
        `  [${rule.id}] ${rule.metric} ${rule.comparison} ${rule.threshold} -> ${rule.severity} (${status})${rule.message ? ` :: ${rule.message}` : ''}`,
      )
    }
  }

  lines.push('')
  lines.push('Recent Tool Events:')
  if (recentToolEvents.length === 0) {
    lines.push('  (none)')
  } else {
    for (const event of recentToolEvents) {
      lines.push(
        `  [${event.timestamp}] ${event.tool} :: ${event.success ? 'success' : 'failed'} (${event.message})`,
      )
    }
  }

  lines.push('')
  lines.push('Pinned Tool Events:')
  if (pinned.length === 0) {
    lines.push('  (none)')
  } else {
    for (const event of pinned) {
      lines.push(
        `  [${event.timestamp}] ${event.tool} :: ${event.success ? 'success' : 'failed'} (${event.message})`,
      )
    }
  }

  lines.push('')
  lines.push('Notification Fix Attempts:')
  if (fixes.length === 0) {
    lines.push('  (none)')
  } else {
    for (const fix of fixes) {
      lines.push(
        `  [${fix.timestamp}] ${fix.step} => ${fix.success ? 'success' : 'failure'}${fix.message ? ` :: ${fix.message}` : ''}`,
      )
    }
  }

  lines.push('')
  lines.push(`Chat Favorites (${favorites.length}):`)
  if (favorites.length === 0) {
    lines.push('  (none)')
  } else {
    for (const favorite of favorites.slice(0, 5)) {
      const preview = favorite.content.length > 160 ? `${favorite.content.slice(0, 157)}â€¦` : favorite.content
      lines.push(`  [${favorite.createdAt}] ${favorite.role}: ${preview}`)
    }
    if (favorites.length > 5) {
      lines.push(`  ... ${favorites.length - 5} more`)
    }
  }

  lines.push('')
  lines.push('Memory Keyword Highlights:')
  if (keywordStats.length === 0) {
    lines.push('  (none)')
  } else {
    for (const keyword of keywordStats) {
      lines.push(`  ${keyword.keyword}: ${keyword.score.toFixed(2)}`)
    }
  }

  return lines.join('\n')
}

function parseAlertRuleCreatePayload(payload: unknown) {
  if (!payload || typeof payload !== 'object') return null
  const record = payload as Record<string, unknown>
  const metric = record.metric
  const comparison = record.comparison
  const threshold = record.threshold
  const severity = record.severity
  const enabled = record.enabled
  const message = typeof record.message === 'string' && record.message.trim().length > 0 ? record.message.trim() : undefined

  if (typeof metric !== 'string' || !ALERT_RULE_METRICS.has(metric as AlertRule['metric'])) return null
  if (typeof comparison !== 'string' || !ALERT_RULE_COMPARISONS.has(comparison as AlertRule['comparison'])) return null
  if (typeof threshold !== 'number' || !Number.isFinite(threshold)) return null
  if (typeof severity !== 'string' || !ALERT_RULE_SEVERITIES.has(severity as AlertRule['severity'])) return null

  const result: {
    metric: AlertRule['metric']
    comparison: AlertRule['comparison']
    threshold: number
    severity: AlertRule['severity']
    message?: string
    enabled: boolean
  } = {
    metric: metric as AlertRule['metric'],
    comparison: comparison as AlertRule['comparison'],
    threshold,
    severity: severity as AlertRule['severity'],
    enabled: typeof enabled === 'boolean' ? enabled : true,
  }

  if (message) {
    result.message = message
  }

  return result
}

function parseAlertRuleUpdatePayload(payload: unknown) {
  if (!payload || typeof payload !== 'object') return null
  const record = payload as Record<string, unknown>
  const comparison = record.comparison
  const threshold = record.threshold
  const severity = record.severity
  const enabled = record.enabled
  const message = typeof record.message === 'string' && record.message.trim().length > 0 ? record.message.trim() : undefined

  if (typeof comparison !== 'string' || !ALERT_RULE_COMPARISONS.has(comparison as AlertRule['comparison'])) return null
  if (typeof threshold !== 'number' || !Number.isFinite(threshold)) return null
  if (typeof severity !== 'string' || !ALERT_RULE_SEVERITIES.has(severity as AlertRule['severity'])) return null
  if (typeof enabled !== 'boolean') return null

  const result: {
    comparison: AlertRule['comparison']
    threshold: number
    severity: AlertRule['severity']
    enabled: boolean
    message?: string
  } = {
    comparison: comparison as AlertRule['comparison'],
    threshold,
    severity: severity as AlertRule['severity'],
    enabled,
  }

  if (message) {
    result.message = message
  }

  return result
}

function isNotificationFixStep(value: unknown): value is NotificationFixLog['step'] {
  return value === 'permission' || value === 'serviceWorker' || value === 'subscription' || value === 'backend'
}

const ALLOWED_ORIGINS = (process.env.ALLOWED_ORIGINS ?? '')
  .split(',')
  .map((value) => value.trim())
  .filter(Boolean)

const HELMET_CONNECT_SRC = (() => {
  const sources = new Set<string>(["'self'"])
  for (const origin of ALLOWED_ORIGINS) {
    if (!origin) continue
    if (origin.startsWith('http://') || origin.startsWith('https://')) {
      sources.add(origin)
      continue
    }
    sources.add(`http://${origin}`)
    sources.add(`https://${origin}`)
  }
  return Array.from(sources)
})()

const IS_PRODUCTION = process.env.NODE_ENV === 'production'
const FORCE_HTTPS = (() => {
  const raw = (process.env.FORCE_HTTPS ?? '').trim().toLowerCase()
  return raw === 'true' || raw === '1' || raw === 'yes'
})()

// In production, CORS must be explicitly configured
if (IS_PRODUCTION && ALLOWED_ORIGINS.length === 0) {
  console.error('âš ï¸  SECURITY WARNING: ALLOWED_ORIGINS not configured in production environment!')
  console.error('âš ï¸  Set ALLOWED_ORIGINS environment variable to allowed frontend origins.')
  console.error('âš ï¸  Example: ALLOWED_ORIGINS=https://example.com,https://app.example.com')
}

// Block wildcard (*) in production
if (IS_PRODUCTION && ALLOWED_ORIGINS.includes('*')) {
  console.error('âš ï¸  SECURITY ERROR: Wildcard (*) is not allowed in ALLOWED_ORIGINS in production!')
  console.error('âš ï¸  Please specify exact origins instead of using "*".')
  process.exit(1)
}

function originMatchesRule(origin: string, rule: string) {
  if (rule === '*') return true

  try {
    const originUrl = new URL(origin)
    const originHost = originUrl.hostname.toLowerCase()
    const originProtocol = originUrl.protocol
    const originPort = originUrl.port

    if (rule.startsWith('http://') || rule.startsWith('https://')) {
      try {
        const ruleUrl = new URL(rule)
        const rulePort = ruleUrl.port || (ruleUrl.protocol === 'https:' ? '443' : '80')
        const candidatePort = originPort || (originProtocol === 'https:' ? '443' : '80')
        return (
          originProtocol === ruleUrl.protocol &&
          originHost === ruleUrl.hostname.toLowerCase() &&
          candidatePort === rulePort
        )
      } catch {
        return origin === rule
      }
    }

    if (rule.startsWith('*.')) {
      const domain = rule.slice(2).toLowerCase()
      return originHost === domain || originHost.endsWith(`.${domain}`)
    }

    const [ruleHost, rulePort] = rule.toLowerCase().split(':')
    if (rulePort) {
      const candidatePort = originPort || (originProtocol === 'https:' ? '443' : '80')
      return originHost === ruleHost && candidatePort === rulePort
    }
    return originHost === ruleHost
  } catch {
    return false
  }
}

function parseNumericEnv(value: string | undefined, fallback: number) {
  if (typeof value === 'undefined') return fallback
  const parsed = Number(value)
  return Number.isFinite(parsed) ? parsed : fallback
}

const JSON_BODY_LIMIT = (() => {
  const raw = (process.env.JSON_BODY_LIMIT ?? '').trim()
  return raw.length > 0 ? raw : '5mb' // Increased default to 5mb for larger payloads while staying within safety bounds
})()

const REQUEST_TIMEOUT_MS = (() => {
  const raw = Number.parseInt(process.env.REQUEST_TIMEOUT_MS ?? '', 10)
  return Number.isFinite(raw) && raw > 0 ? Math.min(raw, 120000) : 60000 // Default 60s, max 120s
})()
const PROMETHEUS_ENABLED = (() => {
  const raw = (process.env.PROMETHEUS_METRICS ?? '').trim().toLowerCase()
  if (raw === '0' || raw === 'false' || raw === 'no' || raw === 'off') return false
  return true
})()

app.use(
  cors({
    origin: (origin, callback) => {
      // No origin (e.g., server-side request, Postman, curl) - allow in dev, reject in prod
      if (!origin) {
        if (IS_PRODUCTION) {
          callback(new Error('Origin header required in production'), false)
          return
        }
        callback(null, true)
        return
      }

      // Empty allowlist - allow all in development, reject all in production
      if (ALLOWED_ORIGINS.length === 0) {
        if (IS_PRODUCTION) {
          console.warn(`[CORS] Rejected origin (no allowlist configured): ${origin}`)
          callback(new Error('CORS not configured'), false)
          return
        }
        // Development mode: allow all
        callback(null, true)
        return
      }

      // Check against allowlist
      const allowed = ALLOWED_ORIGINS.some((rule) => originMatchesRule(origin, rule))
      if (!allowed) {
        console.warn(`[CORS] Rejected origin: ${origin} (not in allowlist)`)
      }
      callback(allowed ? null : new Error('Origin not allowed'), allowed)
    },
    credentials: true,
  }),
)

// ðŸ”’ å®‰å…¨æ¨™é ­ (Security Headers)
// Helmet å¹«åŠ©è¨­å®šå„ç¨® HTTP å®‰å…¨æ¨™é ­ä¾†ä¿è­·æ‡‰ç”¨ç¨‹å¼
// Helmet helps set various HTTP security headers to protect the application
app.use(
  helmet({
    // ðŸ”’ å•Ÿç”¨å…§å®¹å®‰å…¨æ”¿ç­–ï¼ˆContent Security Policyï¼‰/ Enable CSP
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'"], // Reactå¯èƒ½éœ€è¦ inline scripts
        styleSrc: ["'self'", "'unsafe-inline'"], // React inline styles
        imgSrc: ["'self'", 'data:', 'blob:'], // å…è¨± data URIs å’Œ blob åœ–ç‰‡
        connectSrc: HELMET_CONNECT_SRC, // API è«‹æ±‚å…è¨±æ¸…å–®
        fontSrc: ["'self'", 'data:'],
        objectSrc: ["'none'"], // ç¦æ­¢ Flash ç­‰ plugins
        mediaSrc: ["'self'", 'blob:'], // éŸ³è¨Š/è¦–è¨Šæª”æ¡ˆ
        frameSrc: ["'none'"], // ç¦æ­¢ iframe åµŒå…¥
        upgradeInsecureRequests: [], // è‡ªå‹•å‡ç´š HTTP åˆ° HTTPS
      },
    },
    crossOriginEmbedderPolicy: false, // å…è¨±è·¨åŸŸåµŒå…¥ï¼ˆPWA éœ€è¦ï¼‰
    crossOriginResourcePolicy: {
      policy: 'cross-origin', // å…è¨±å‰ç«¯ä½¿ç”¨è·¨ä¾†æº fetch å–å¾— API
    },
    // å…¶ä»–å®‰å…¨æ¨™é ­ helmet æœƒè‡ªå‹•å•Ÿç”¨ï¼š
    // - X-Content-Type-Options: nosniff
    // - X-Frame-Options: SAMEORIGIN
    // - X-XSS-Protection: 0 (modern browsers use CSP)
    // - Strict-Transport-Security (HTTPS only)
  }),
)

// ðŸ”’ HTTPS å¼·åˆ¶é‡å®šå‘ / HTTPS Enforcement
// åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ï¼Œå¼·åˆ¶æ‰€æœ‰ HTTP è«‹æ±‚é‡å®šå‘åˆ° HTTPS
// In production, force all HTTP requests to redirect to HTTPS
if (FORCE_HTTPS) {
  app.use((req, res, next) => {
    // æª¢æŸ¥æ˜¯å¦ç‚º HTTPS é€£æŽ¥
    // Check if connection is already HTTPS
    const isSecure = req.secure || req.headers['x-forwarded-proto'] === 'https'

    if (!isSecure) {
      // æ§‹å»º HTTPS URL / Build HTTPS URL
      const host = req.headers.host || req.hostname
      const httpsUrl = `https://${host}${req.url}`

      console.log(`[https] Redirecting HTTP request to HTTPS: ${req.url}`)

      // ä½¿ç”¨ 301 æ°¸ä¹…é‡å®šå‘ / Use 301 permanent redirect
      res.redirect(301, httpsUrl)
      return
    }

    next()
  })
  console.log('[https] HTTPS enforcement enabled - HTTP requests will be redirected')
} else {
  console.log('[https] HTTPS enforcement disabled (set FORCE_HTTPS=true to enable)')
}

// ðŸ”’ é€ŸçŽ‡é™åˆ¶ï¼ˆå¯é…ç½®ï¼‰/ Rate Limiting (configurable)
// çŽ¯å¢ƒå˜é‡é…ç½® / Environment variable configuration
const RATE_LIMIT_GENERAL_WINDOW_MS = Number.parseInt(
  process.env.RATE_LIMIT_GENERAL_WINDOW_MS ?? '900000',
  10,
) // é»˜è®¤ 15 åˆ†é’Ÿ / Default 15 minutes
const RATE_LIMIT_GENERAL_MAX = Number.parseInt(
  process.env.RATE_LIMIT_GENERAL_MAX ?? '100',
  10,
) // é»˜è®¤ 100 è¯·æ±‚ / Default 100 requests
const RATE_LIMIT_CHAT_WINDOW_MS = Number.parseInt(
  process.env.RATE_LIMIT_CHAT_WINDOW_MS ?? '300000',
  10,
) // é»˜è®¤ 5 åˆ†é’Ÿ / Default 5 minutes
const RATE_LIMIT_CHAT_MAX = Number.parseInt(
  process.env.RATE_LIMIT_CHAT_MAX ?? '10',
  10,
) // é»˜è®¤ 10 è¯·æ±‚ / Default 10 requests

// ä¸€èˆ¬ API é™åˆ¶ / General API rate limiting
const generalLimiter = rateLimit({
  windowMs: RATE_LIMIT_GENERAL_WINDOW_MS,
  max: RATE_LIMIT_GENERAL_MAX,
  message: { ok: false, message: 'Too many requests, please try again later.' },
  standardHeaders: true, // åœ¨ `RateLimit-*` æ ‡å¤´è¿”å›žé€ŸçŽ‡é™åˆ¶ä¿¡æ¯ / Return rate limit info in `RateLimit-*` headers
  legacyHeaders: false, // åœç”¨ `X-RateLimit-*` æ ‡å¤´ / Disable `X-RateLimit-*` headers
})

// AI èŠå¤©é™åˆ¶ï¼ˆé¿å…æ»¥ç”¨æ˜‚è´µçš„ AI è¿ç®—ï¼‰/ AI chat rate limiting (avoid abuse of expensive AI computation)
const chatLimiter = rateLimit({
  windowMs: RATE_LIMIT_CHAT_WINDOW_MS,
  max: RATE_LIMIT_CHAT_MAX,
  message: { ok: false, message: 'Too many AI chat requests, please try again later.' },
  standardHeaders: true,
  legacyHeaders: false,
})

const RATE_LIMIT_TTS_WINDOW_MS = Math.max(
  30_000,
  parseNumericEnv(process.env.RATE_LIMIT_TTS_WINDOW_MS, 60_000),
)
const RATE_LIMIT_TTS_MAX = Math.max(1, parseNumericEnv(process.env.RATE_LIMIT_TTS_MAX, 6))
const ttsLimiter = rateLimit({
  windowMs: RATE_LIMIT_TTS_WINDOW_MS,
  max: RATE_LIMIT_TTS_MAX,
  message: { ok: false, message: 'Too many TTS requests, please try again later.' },
  standardHeaders: true,
  legacyHeaders: false,
})

// ðŸ”’ ç™»å…¥é€ŸçŽ‡é™åˆ¶ï¼ˆé˜²æ­¢æš´åŠ›ç ´è§£æ”»æ“Šï¼‰/ Login rate limiting (prevent brute force attacks)
const RATE_LIMIT_LOGIN_WINDOW_MS = Math.max(
  60_000, // Minimum 1 minute / æœ€å°‘ 1 åˆ†é˜
  parseNumericEnv(process.env.RATE_LIMIT_LOGIN_WINDOW_MS, 900_000), // Default 15 minutes / é è¨­ 15 åˆ†é˜
)
const RATE_LIMIT_LOGIN_MAX = Math.max(1, parseNumericEnv(process.env.RATE_LIMIT_LOGIN_MAX, 5)) // Default 5 attempts / é è¨­ 5 æ¬¡
const loginLimiter = rateLimit({
  windowMs: RATE_LIMIT_LOGIN_WINDOW_MS,
  max: RATE_LIMIT_LOGIN_MAX,
  message: {
    ok: false,
    message: 'Too many login attempts. Please try again later.',
    retryAfter: Math.ceil(RATE_LIMIT_LOGIN_WINDOW_MS / 1000), // Seconds / ç§’æ•¸
  },
  standardHeaders: true,
  legacyHeaders: false,
  // è·³éŽæˆåŠŸçš„ç™»å…¥è«‹æ±‚ï¼Œåªè¨ˆç®—å¤±æ•—çš„å˜—è©¦ / Skip successful logins, only count failed attempts
  skipSuccessfulRequests: true,
})

console.log(`[rate-limit] General: ${RATE_LIMIT_GENERAL_MAX} requests per ${RATE_LIMIT_GENERAL_WINDOW_MS / 1000}s`)
console.log(`[rate-limit] Chat: ${RATE_LIMIT_CHAT_MAX} requests per ${RATE_LIMIT_CHAT_WINDOW_MS / 1000}s`)
console.log(`[rate-limit] TTS: ${RATE_LIMIT_TTS_MAX} requests per ${RATE_LIMIT_TTS_WINDOW_MS / 1000}s`)
console.log(`[rate-limit] Login: ${RATE_LIMIT_LOGIN_MAX} attempts per ${RATE_LIMIT_LOGIN_WINDOW_MS / 1000}s (failed attempts only)`)


// å¥—ç”¨ä¸€èˆ¬é€ŸçŽ‡é™åˆ¶åˆ°æ‰€æœ‰è·¯ç”± / Apply general rate limiting to all routes
app.use(generalLimiter)

app.use(express.json({ limit: JSON_BODY_LIMIT }))
app.use(morgan('dev'))

// Request timeout middleware
app.use((req, res, next) => {
  req.setTimeout(REQUEST_TIMEOUT_MS, () => {
    res.status(408).json({ ok: false, message: 'request-timeout' })
  })
  res.setTimeout(REQUEST_TIMEOUT_MS, () => {
    res.status(408).json({ ok: false, message: 'response-timeout' })
  })
  next()
})

app.use((req, _res, next) => {
  attachAuthContext(req)
  next()
})

// ðŸ”§ ä¿®å¤ï¼šå¼€å‘æ¨¡å¼è‡ªåŠ¨ç™»å½•ï¼ˆè§£å†³ 401 æœªæŽˆæƒé”™è¯¯ï¼‰
app.use((req, _res, next) => {
  attachDevSession(req)
  next()
})

app.get('/api/mcp/tools', (_req, res) => {
  const definitions = getMcpToolDefinitions()
  const tools = definitions.map((entry) => ({
    name: entry.function.name,
    description: typeof entry.function.description === 'string' ? entry.function.description : '',
    parameters:
      entry.function.parameters && typeof entry.function.parameters === 'object'
        ? entry.function.parameters
        : null,
  }))
  res.json({
    ok: true,
    data: {
      enabled: isMcpEnabled(),
      count: tools.length,
      tools,
    },
  })
})

app.post('/mcp/invoke', async (req, res) => {
  const tool = typeof req.body?.tool === 'string' ? req.body.tool.trim() : ''
  const args = req.body?.args ?? {}
  if (!tool) {
    res.status(400).json({ ok: false, message: 'missing-tool' })
    return
  }
  if (!listLocalMcpTools().includes(tool)) {
    res.status(404).json({ ok: false, message: `unknown-tool:${tool}` })
    return
  }
  try {
    const result = await invokeLocalMcpTool(tool, args)
    const payload = {
      tool,
      output: result.output,
      payload: result.data ?? null,
    }
    res.json({
      ok: true,
      ...payload,
      data: payload,
    })
  } catch (error) {
    console.error('[mcp] Local handler failed:', error)
    res.status(400).json({
      ok: false,
      message: error instanceof Error ? error.message : 'mcp-handler-error',
    })
  }
})

const HISTORY_LIMIT = Math.max(1, parseNumericEnv(process.env.HISTORY_LIMIT, DEFAULT_HISTORY_LIMIT))
const ALERT_HISTORY_LIMIT = Math.max(1, parseNumericEnv(process.env.ALERT_HISTORY_LIMIT, 50))
const PUSH_BATCH_SIZE = Math.max(1, parseNumericEnv(process.env.PUSH_BATCH_SIZE, 10))
const PUSH_BATCH_DELAY_MS = Math.max(0, parseNumericEnv(process.env.PUSH_BATCH_DELAY_MS, 200))

function indicatesWebSearch(text: string): boolean {
  if (!text) return false
  const lowered = text.toLowerCase()
  return (
    lowered.includes('search') ||
    lowered.includes('look up') ||
    lowered.includes('google') ||
    /ä¸Šç¶²æŸ¥|ç¶²è·¯æœå°‹|å¹«æˆ‘æŸ¥|æŸ¥ä¸€ä¸‹/.test(text)
  )
}
const MAX_TOOL_CALL_ITERATIONS = Math.max(
  2,
  parseNumericEnv(process.env.MAX_TOOL_CALL_ITERATIONS, 5),
)

async function evaluateUltraSafetyDecision(input: string, language: LanguageCode) {
  let decision = enforceCatOnlyAnswer(input, language)
  if (!decision) {
    const classifierDecision = await classifyPromptSafety(input, language)
    if (classifierDecision && classifierDecision.label !== 'allow') {
      const violation = classifierDecision.label === 'non-cat' ? 'non_cat' : 'prompt_injection'
      decision = {
        reason: violation,
        message: classifierDecision.reason?.trim().length
          ? classifierDecision.reason.trim()
          : buildPolicyMessage(violation, language),
      }
    }
  }
  if (decision) {
    return decision
  }
  return null
}

const storedSettings = loadStoredSettings()

const DEFAULT_CAT_ID = 'default'
const catRegistry = new Map<string, CatProfile>()
for (const cat of listCats()) {
  catRegistry.set(cat.id, cat)
}
if (!catRegistry.has(DEFAULT_CAT_ID)) {
  const fallback = upsertCat({ id: DEFAULT_CAT_ID, name: 'Default Cat' })
  catRegistry.set(fallback.id, fallback)
}

let activeCatId = catRegistry.has(DEFAULT_CAT_ID)
  ? DEFAULT_CAT_ID
  : catRegistry.values().next()?.value?.id ?? DEFAULT_CAT_ID

const latestSnapshotsByCat = new Map<string, SmartHomeSnapshot>()
for (const cat of catRegistry.values()) {
  const snapshot = loadLatestSnapshot(cat.id)
  if (snapshot) {
    const normalized = snapshot.catId ? snapshot : { ...snapshot, catId: cat.id }
    latestSnapshotsByCat.set(cat.id, normalized)
  }
}

const pendingBehaviorRefreshTimers = new Map<string, NodeJS.Timeout>()
const BEHAVIOR_REFRESH_DELAY_MS = 2_000

for (const catId of catRegistry.keys()) {
  setTimeout(() => {
    try {
      ensureBehaviorProfile(catId)
    } catch (error) {
      console.warn('[behavior] Failed to prime behavior profile for cat', catId, error)
    }
  }, 0)
}

// Mutex for protecting latestSnapshot from race conditions
class Mutex {
  private locked = false
  private queue: (() => void)[] = []

  async acquire(): Promise<() => void> {
    return new Promise((resolve) => {
      if (!this.locked) {
        this.locked = true
        resolve(() => this.release())
      } else {
        this.queue.push(() => resolve(() => this.release()))
      }
    })
  }

  private release(): void {
    const next = this.queue.shift()
    if (next) {
      next()
    } else {
      this.locked = false
    }
  }
}

const snapshotMutex = new Mutex()

let currentSettings: SmartHomeSettings = storedSettings ?? DEFAULT_SETTINGS
let latestSnapshot: SmartHomeSnapshot | null = latestSnapshotsByCat.get(activeCatId) ?? null
const languageContext = new AsyncLocalStorage<LanguageCode>()
let persistedLanguage: LanguageCode = loadLanguage()
function getPreferredLanguage(): LanguageCode {
  return languageContext.getStore() ?? persistedLanguage
}
function runWithLanguageContext<T>(language: LanguageCode, fn: () => Promise<T>): Promise<T> {
  return languageContext.run(language, fn)
}
function resolveRequestLanguage(rawLanguage: unknown): LanguageCode {
  return rawLanguage === 'zh' || rawLanguage === 'en' ? rawLanguage : getPreferredLanguage()
}
function setPersistedLanguage(language: LanguageCode) {
  if (persistedLanguage === language) return
  persistedLanguage = language
  try {
    saveLanguage(language)
  } catch (error) {
    console.warn('[language] Failed to persist preferred language', error)
  }
}

let currentCalibration: CalibrationProfile | null = loadCalibration()
configureCameraFromEnv()
let latestVisionStatus: VisionStatus = getCameraRuntime()
let latestAudioStatus: AudioStatus | null =
  latestSnapshot && latestSnapshot.reading.audio ? { ...latestSnapshot.reading.audio } : null

if (latestSnapshot) {
  if (latestSnapshot.reading.vision) {
    updateCameraRuntimeFromReading(latestSnapshot.reading.vision)
    latestVisionStatus = getCameraRuntime()
  } else {
    patchLatestVisionStatus(latestVisionStatus)
  }
  if (!latestSnapshot.reading.audio && latestAudioStatus) {
    patchLatestAudioStatus(latestAudioStatus)
  }
}
const HARDWARE_API_KEY = (process.env.HARDWARE_API_KEY ?? '').trim()
const ADMIN_API_KEY = (process.env.ADMIN_API_KEY ?? '').trim()
const ENABLE_TTS = ['true', '1', 'yes'].includes((process.env.ENABLE_TTS ?? 'true').toLowerCase())
const TTS_MODEL_ID = process.env.TTS_MODEL_ID ?? 'Xenova/xtts-v2'
const DEFAULT_CAT_PRESENCE_KG =
  Number.isFinite(Number(process.env.CAT_PRESENCE_WEIGHT_KG))
    ? Number(process.env.CAT_PRESENCE_WEIGHT_KG)
    : 1
let recentAlerts: AutomationAlert[] = loadAutomationAlerts(ALERT_HISTORY_LIMIT)
let serialBridge: SerialBridgeConnection | null = null

const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY
const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY
const VAPID_CONTACT = process.env.VAPID_CONTACT ?? 'mailto:smart-cat-home@example.com'
let pushNotificationsEnabled = false

if (VAPID_PUBLIC_KEY && VAPID_PRIVATE_KEY) {
  try {
    webPush.setVapidDetails(VAPID_CONTACT, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY)
    pushNotificationsEnabled = true
  } catch (error) {
    console.warn('[push] Failed to configure VAPID keys', error)
  }
} else {
  console.warn('[push] VAPID_PUBLIC_KEY / VAPID_PRIVATE_KEY not set; push notifications disabled.')
}

type PushAlertInput =
  | {
      message: string
      severity?: AutomationAlert['severity']
    }
  | {
      key: AlertMessageKey
      variables?: Record<string, string | number | boolean>
      severity?: AutomationAlert['severity']
    }

// ðŸš¨ Alert rate limiting: Prevent alert spam with cooldown periods
const ALERT_COOLDOWN_MS = 5 * 60 * 1000 // 5 minutes
const alertCooldowns = new Map<string, number>() // key -> expiryTimestamp

// Cleanup expired cooldowns periodically to prevent memory leak
setInterval(() => {
  const now = Date.now()
  for (const [key, expiry] of alertCooldowns.entries()) {
    if (expiry < now) {
      alertCooldowns.delete(key)
    }
  }
}, 60 * 1000) // Run cleanup every minute

// â±ï¸ Hardware command timeout: Reset stale commands every minute
// If Arduino crashes after claiming a command, it will be automatically retried
const COMMAND_TIMEOUT_MS = 5 * 60 * 1000 // 5 minutes
setInterval(() => {
  const resetCount = resetStaleHardwareCommands(COMMAND_TIMEOUT_MS)
  if (resetCount > 0) {
    console.log(`[hardware] Timeout check: reset ${resetCount} stale command(s)`)
  }
}, 60 * 1000) // Check every minute

function pushAlert(input: PushAlertInput) {
  const severity = input.severity ?? 'warning'
  let message: string
  let messageKey: AlertMessageKey | undefined
  let messageVariables: Record<string, string | number | boolean> | undefined

  if ('message' in input) {
    message = input.message
  } else {
    messageKey = input.key
    messageVariables = input.variables ? { ...input.variables } : undefined
    const normalizedVariables = Object.fromEntries(
      Object.entries(messageVariables ?? {}).map(([key, value]) => [
        key,
        typeof value === 'boolean' ? (value ? 'true' : 'false') : value,
      ]),
    ) as Record<string, string | number>
    message = formatAlertMessage(input.key, normalizedVariables)
  }

  // ðŸš¨ Check cooldown: Create unique key for this alert type
  const cooldownKey = messageKey
    ? `${messageKey}-${JSON.stringify(messageVariables ?? {})}`
    : `msg-${message}`

  const cooldownExpiry = alertCooldowns.get(cooldownKey)
  if (cooldownExpiry && Date.now() < cooldownExpiry) {
    // Still in cooldown period, skip this alert
    return
  }

  const lastAlert = recentAlerts[0]
  if (lastAlert) {
    if (messageKey && lastAlert.messageKey === messageKey) {
      const previous = JSON.stringify(lastAlert.messageVariables ?? {})
      const next = JSON.stringify(messageVariables ?? {})
      if (previous === next && lastAlert.severity === severity) {
        return
      }
    } else if (!messageKey && lastAlert.message === message && lastAlert.severity === severity) {
      return
    }
  }

  const alert: AutomationAlert = {
    timestamp: new Date().toISOString(),
    message,
    severity,
    ...(messageKey ? { messageKey } : {}),
    ...(messageVariables ? { messageVariables } : {}),
  }
  recentAlerts = [alert, ...recentAlerts].slice(0, ALERT_HISTORY_LIMIT)
  try {
    saveAutomationAlert(alert, ALERT_HISTORY_LIMIT)
  } catch (error) {
    console.warn('[alerts] Failed to persist automation alert', error)
  }
  if (pushNotificationsEnabled) {
    void notifyAlert(alert)
  }

  // ðŸš¨ Set cooldown for this alert type
  alertCooldowns.set(cooldownKey, Date.now() + ALERT_COOLDOWN_MS)
}

function sendHardwareCommand(type: 'updateSettings' | 'updateCalibration', payload: unknown) {
  if (serialBridge) {
    serialBridge
      .sendCommand({
        type,
        payload,
        timestamp: new Date().toISOString(),
      })
      .catch((error) => {
        console.warn('[serial] Failed to send hardware command', type, error)
      })
    return
  }

  try {
    enqueueHardwareCommand(type, payload)
  } catch (error) {
    console.warn('[hardware] Failed to enqueue hardware command', type, error)
  }
}

function pushSettingsToHardware(settings: SmartHomeSettings) {
  sendHardwareCommand('updateSettings', settings)
}

function pushCalibrationToHardware(calibration: CalibrationProfile) {
  sendHardwareCommand('updateCalibration', calibration)
}

const DEFAULT_AUDIO_STATUS: AudioStatus = {
  amplifierOnline: true,
  muted: false,
  volumePercent: 70,
  activePattern: 'none',
  playing: false,
  lastPattern: null,
  lastTriggeredAtMs: undefined,
}

function patchLatestAudioStatus(partial: Partial<AudioStatus>) {
  const base = latestAudioStatus ? { ...latestAudioStatus } : { ...DEFAULT_AUDIO_STATUS }
  const next: AudioStatus = {
    ...base,
    ...partial,
  }
  next.volumePercent = Math.max(0, Math.min(100, next.volumePercent))
  latestAudioStatus = next

  if (latestSnapshot) {
    const updated: SmartHomeSnapshot = {
      ...latestSnapshot,
      reading: {
        ...latestSnapshot.reading,
        audio: { ...next },
      },
    }
    latestSnapshot = updated
    const targetCat = updated.catId ?? activeCatId
    latestSnapshotsByCat.set(targetCat, updated)
  }
}

function sendSerialAudioControl(payload: Record<string, unknown>) {
  if (!serialBridge) {
    return
  }
  serialBridge
    .sendCommand({
      type: 'audioControl',
      payload,
      timestamp: new Date().toISOString(),
    })
    .catch((error) => {
      console.warn('[audio] Failed to send serial audio control', error)
    })
}

function triggerAudioPattern(pattern: string, repeat = 1) {
  const sanitizedPattern = pattern.trim().length > 0 ? pattern.trim() : 'call-cat'
  const repeatCount = Number.isFinite(repeat) && repeat > 0 ? repeat : 1

  if (serialBridge) {
    sendSerialAudioControl({ action: 'playPattern', pattern: sanitizedPattern, repeat: repeatCount })
  } else {
    enqueueHardwareCommand('playAudioPattern', { pattern: sanitizedPattern, repeat: repeatCount })
  }

  patchLatestAudioStatus({
    amplifierOnline: latestAudioStatus?.amplifierOnline ?? true,
    activePattern: sanitizedPattern,
    lastPattern: sanitizedPattern,
    playing: true,
    lastTriggeredAtMs: Date.now(),
  })
}

function stopAudioPlayback() {
  if (serialBridge) {
    sendSerialAudioControl({ action: 'stop' })
  } else {
    enqueueHardwareCommand('stopAudio', null)
  }

  patchLatestAudioStatus({
    activePattern: 'none',
    playing: false,
  })
}

function updateAudioConfiguration(options: {
  muted?: boolean | undefined
  volumePercent?: number | undefined
  pattern?: string | undefined
  repeat?: number | undefined
}) {
  const payload: Record<string, unknown> = {}
  if (typeof options.muted === 'boolean') {
    payload.muted = options.muted
  }
  if (typeof options.volumePercent === 'number' && Number.isFinite(options.volumePercent)) {
    payload.volumePercent = Math.max(0, Math.min(100, options.volumePercent))
  }
  if (typeof options.pattern === 'string' && options.pattern.trim().length > 0) {
    payload.pattern = options.pattern.trim()
    if (typeof options.repeat === 'number' && Number.isFinite(options.repeat)) {
      payload.repeat = options.repeat
    }
  }

  if (serialBridge) {
    if (typeof payload.volumePercent === 'number') {
      sendSerialAudioControl({ action: 'setVolume', volumePercent: payload.volumePercent })
    }
    if (typeof payload.muted === 'boolean') {
      sendSerialAudioControl({
        action: payload.muted ? 'mute' : 'unmute',
        muted: payload.muted,
      })
    }
    if (typeof payload.pattern === 'string') {
      triggerAudioPattern(payload.pattern, typeof payload.repeat === 'number' ? payload.repeat : 1)
      return
    }
  } else if (Object.keys(payload).length > 0) {
    enqueueHardwareCommand('setAudioState', payload)
  }

  const partial: Partial<AudioStatus> = {}
  if (typeof payload.volumePercent === 'number') {
    partial.volumePercent = payload.volumePercent
  }
  if (typeof payload.muted === 'boolean') {
    partial.muted = payload.muted
    partial.playing = payload.muted ? false : latestAudioStatus?.playing ?? false
    if (payload.muted) {
      partial.activePattern = 'none'
    }
  }
  if (typeof payload.pattern === 'string') {
    patchLatestAudioStatus({
      activePattern: payload.pattern,
      lastPattern: payload.pattern,
      playing: true,
      lastTriggeredAtMs: Date.now(),
    })
    return
  }

  if (Object.keys(partial).length > 0) {
    patchLatestAudioStatus(partial)
  }
}

function patchLatestVisionStatus(status: VisionStatus) {
  latestVisionStatus = {
    ...status,
    inference: status.inference ? { ...status.inference } : status.inference ?? null,
  }

  if (latestSnapshot) {
    const updated: SmartHomeSnapshot = {
      ...latestSnapshot,
      reading: {
        ...latestSnapshot.reading,
        vision: latestVisionStatus,
      },
    }
    latestSnapshot = updated
    const targetCat = updated.catId ?? activeCatId
    latestSnapshotsByCat.set(targetCat, updated)
  }
}

function getCatPresenceThresholdKg() {
  return currentCalibration?.catPresenceThresholdKg ?? DEFAULT_CAT_PRESENCE_KG
}

const ALERT_TRANSLATIONS: Record<
  LanguageCode,
  Record<
    | 'waterLevelCritical'
    | 'waterLevelLow'
    | 'brightnessLow'
    | 'brightnessHigh'
    | 'catLeft'
    | 'catAwayTooLong',
    string
  >
> = {
  zh: {
    waterLevelCritical: 'æ°´ä½åƒ…å‰© {percent}%ï¼Œè«‹ç«‹å³è£œæ°´ã€‚',
    waterLevelLow: 'æ°´ä½åä½Žï¼ˆ{percent}%ï¼‰ï¼Œå»ºè­°å„˜å¿«è£œæ°´ã€‚',
    brightnessLow: 'åµæ¸¬åˆ°è²“å’ªåœ¨å±‹å…§ä¸”ç’°å¢ƒäº®åº¦åæš—ï¼Œè«‹è€ƒæ…®é–‹ç‡ˆæˆ–å¢žåŠ ç…§æ˜Žã€‚',
    brightnessHigh: 'åµæ¸¬åˆ°è²“å’ªåœ¨å±‹å…§ä¸”äº®åº¦éŽé«˜ï¼ˆ{percent}%ï¼‰ï¼Œè«‹æª¢æŸ¥æ˜¯å¦æœ‰å¼·å…‰æˆ–ç›´å°„æ—¥å…‰ã€‚',
    catLeft: 'åµæ¸¬åˆ°è²“å’ªå‰›é›¢é–‹æ™ºæ…§è²“å±‹ï¼Œè«‹ç¢ºèªæ˜¯å¦ç‚ºé æœŸæƒ…æ³ã€‚',
    catAwayTooLong: 'è²“å’ªé›¢é–‹è¶…éŽ 6 å°æ™‚ä¸”æœªé¤µé£Ÿï¼Œè«‹ç¢ºèªå…¶ç‹€æ…‹ã€‚',
  },
  en: {
    waterLevelCritical: 'Water level at {percent}%. Refill immediately.',
    waterLevelLow: 'Water level low ({percent}%). Schedule a refill soon.',
    brightnessLow: 'Brightness is very low while the cat is inside. Consider turning on the lights.',
    brightnessHigh: 'Brightness extremely high ({percent}%) while the cat is inside. Check for direct sunlight or glare.',
    catLeft: 'Cat just left the habitat. Monitor if this was expected.',
    catAwayTooLong: 'Cat has been away for over 6 hours since last feeding. Please check on them.',
  },
}

function formatAlertMessage(
  key: AlertMessageKey,
  variables: Record<string, string | number> = {},
) {
  const language = getPreferredLanguage()
  const template = ALERT_TRANSLATIONS[language]?.[key] ?? ALERT_TRANSLATIONS.en[key] ?? key
  return template.replace(/\{(\w+)\}/g, (_match, token: string) => {
    const value = variables[token]
    return value !== undefined ? String(value) : ''
  })
}

const CALIBRATION_KEYS: Array<keyof CalibrationProfile> = [
  'fsrZero',
  'fsrScale',
  'waterLevelFullCm',
  'waterLevelEmptyCm',
  'ldrDark',
  'ldrBright',
  'catPresenceThresholdKg',
]

function formatDecimal(value: number | undefined, fractionDigits = 1): string {
  if (typeof value !== 'number' || !Number.isFinite(value)) {
    return 'â€”'
  }
  const fixed = value.toFixed(fractionDigits)
  return fixed.replace(/\.0+$/, '').replace(/(\.[0-9]*[1-9])0+$/, '$1')
}

function numbersDifferent(a: number | undefined, b: number | undefined, tolerance = 0.0001): boolean {
  if (typeof a !== 'number' || !Number.isFinite(a)) {
    return typeof b === 'number' && Number.isFinite(b)
  }
  if (typeof b !== 'number' || !Number.isFinite(b)) {
    return true
  }
  return Math.abs(a - b) > tolerance
}

function describeSettingsChanges(previous: SmartHomeSettings, next: SmartHomeSettings): string[] {
  const changes: string[] = []

  if (previous.autoMode !== next.autoMode) {
    changes.push(`autoMode ${previous.autoMode ? 'ON' : 'OFF'}â†’${next.autoMode ? 'ON' : 'OFF'}`)
  }
  if (numbersDifferent(previous.targetTemperatureC, next.targetTemperatureC, 0.05)) {
    changes.push(`æº«åº¦ ${formatDecimal(previous.targetTemperatureC, 1)}Â°Câ†’${formatDecimal(next.targetTemperatureC, 1)}Â°C`)
  }
  if (numbersDifferent(previous.targetHumidityPercent, next.targetHumidityPercent, 0.5)) {
    changes.push(`æ¿•åº¦ ${formatDecimal(previous.targetHumidityPercent, 0)}%â†’${formatDecimal(next.targetHumidityPercent, 0)}%`)
  }
  if (numbersDifferent(previous.waterBowlLevelTargetMl, next.waterBowlLevelTargetMl, 0.5)) {
    changes.push(`æ°´ç¢—ç›®æ¨™ ${formatDecimal(previous.waterBowlLevelTargetMl, 0)}mlâ†’${formatDecimal(next.waterBowlLevelTargetMl, 0)}ml`)
  }
  const prevSchedule = previous.feederSchedule.trim()
  const nextSchedule = next.feederSchedule.trim()
  if (prevSchedule !== nextSchedule) {
    changes.push(`é¤µé£Ÿè¡Œç¨‹ ${prevSchedule.length > 0 ? prevSchedule : 'â€”'}â†’${nextSchedule.length > 0 ? nextSchedule : 'â€”'}`)
  }
  if (previous.purifierIntensity !== next.purifierIntensity) {
    changes.push(`ç©ºæ°£æ·¨åŒ– ${previous.purifierIntensity}â†’${next.purifierIntensity}`)
  }

  return changes
}

function recordSettingsMemory(previous: SmartHomeSettings, next: SmartHomeSettings, source: string) {
  const changes = describeSettingsChanges(previous, next)
  if (!changes.length) return
  const content = `Autoset è¨­å®šæ›´æ–°ï¼š${changes.join('ï¼›')}`
  try {
    addMemory({ type: 'setting', content, source })
  } catch (error) {
    console.warn('[memories] Failed to persist settings change', error)
  }
}

const CALIBRATION_LABELS: Record<keyof CalibrationProfile, string> = {
  fsrZero: 'FSR é›¶é»ž',
  fsrScale: 'FSR æ¯”ä¾‹',
  waterLevelFullCm: 'æ°´ä½ï¼ˆæ»¿ï¼‰',
  waterLevelEmptyCm: 'æ°´ä½ï¼ˆç©ºï¼‰',
  ldrDark: 'LDR æš—éƒ¨',
  ldrBright: 'LDR äº®éƒ¨',
  catPresenceThresholdKg: 'è²“å’ªå…¥å±‹é–¾å€¼',
  updatedAt: 'æ›´æ–°æ™‚é–“',
}

const CALIBRATION_PRECISION: Partial<Record<keyof CalibrationProfile, number>> = {
  fsrScale: 6,
  catPresenceThresholdKg: 2,
  waterLevelFullCm: 2,
  waterLevelEmptyCm: 2,
}

const CALIBRATION_TOLERANCE: Partial<Record<keyof CalibrationProfile, number>> = {
  fsrScale: 1e-6,
  catPresenceThresholdKg: 0.005,
  waterLevelFullCm: 0.02,
  waterLevelEmptyCm: 0.02,
}

function formatCalibrationValue(key: keyof CalibrationProfile, value: number | undefined): string {
  if (typeof value !== 'number' || !Number.isFinite(value)) {
    return 'â€”'
  }
  const digits = CALIBRATION_PRECISION[key] ?? (Math.abs(value) >= 10 ? 1 : 2)
  const text = formatDecimal(value, digits)
  if (key === 'catPresenceThresholdKg') return `${text}kg`
  if (key === 'waterLevelFullCm' || key === 'waterLevelEmptyCm') return `${text}cm`
  if (key === 'fsrZero' || key === 'ldrDark' || key === 'ldrBright') return text
  if (key === 'fsrScale') return text
  return text
}

function describeCalibrationChanges(previous: CalibrationProfile | null, next: CalibrationProfile): string[] {
  const changes: string[] = []
  for (const key of CALIBRATION_KEYS) {
    const label = CALIBRATION_LABELS[key] ?? key
    const prevHas = previous ? Object.prototype.hasOwnProperty.call(previous, key) : false
    const nextHas = Object.prototype.hasOwnProperty.call(next, key)
    const prevValue = prevHas ? (previous as Record<string, unknown>)[key] : undefined
    const nextValue = nextHas ? (next as Record<string, unknown>)[key] : undefined

    if (!prevHas && !nextHas) {
      continue
    }
    if (!nextHas) {
      const before = typeof prevValue === 'number' ? formatCalibrationValue(key, prevValue) : 'â€”'
      changes.push(`${label} ç§»é™¤ï¼ˆåŽŸå€¼ ${before}ï¼‰`)
      continue
    }
    if (!prevHas) {
      const after = typeof nextValue === 'number' ? formatCalibrationValue(key, nextValue) : 'â€”'
      changes.push(`${label} è¨­ç‚º ${after}`)
      continue
    }
    if (
      typeof prevValue === 'number' &&
      typeof nextValue === 'number' &&
      !numbersDifferent(prevValue, nextValue, CALIBRATION_TOLERANCE[key] ?? 0.0001)
    ) {
      continue
    }
    if (prevValue === nextValue) {
      continue
    }
    const before = typeof prevValue === 'number' ? formatCalibrationValue(key, prevValue) : 'â€”'
    const after = typeof nextValue === 'number' ? formatCalibrationValue(key, nextValue) : 'â€”'
    changes.push(`${label} ${before}â†’${after}`)
  }
  return changes
}

function recordCalibrationMemory(previous: CalibrationProfile | null, next: CalibrationProfile, source: string) {
  const changes = describeCalibrationChanges(previous, next)
  if (!changes.length) return
  const content = `æ ¡æ­£å€¼æ›´æ–°ï¼š${changes.join('ï¼›')}`
  try {
    addMemory({ type: 'setting', content, source })
  } catch (error) {
    console.warn('[memories] Failed to persist calibration change', error)
  }
}

function normalizeCalibrationPayload(payload: unknown): { profile: CalibrationProfile; changed: boolean } | null {
  if (!payload || typeof payload !== 'object') return null
  const next: CalibrationProfile = { ...(currentCalibration ?? {}) }
  let changed = false

  for (const key of CALIBRATION_KEYS) {
    if (!(key in (payload as Record<string, unknown>))) continue
    const raw = (payload as Record<string, unknown>)[key]
    if (raw === null || raw === '' || typeof raw === 'undefined') {
      if (key in next) {
        delete next[key]
        changed = true
      }
      continue
    }
    const value = typeof raw === 'number' ? raw : Number(raw)
    if (Number.isFinite(value)) {
      Object.assign(next, { [key]: value })
      changed = true
    }
  }

  if (!changed) {
    return { profile: next, changed: false }
  }

  next.updatedAt = new Date().toISOString()
  return { profile: next, changed: true }
}

type ImageAttachment = {
  imageBase64?: string | undefined
  imageUrl?: string | undefined
  mimeType?: string | undefined
}

type DocumentAttachment = {
  dataUrl: string
  mimeType: string
  filename?: string
  type: 'pdf' | 'word'
}

function detectAttachmentType(mimeType?: string, filename?: string): 'image' | 'pdf' | 'word' | 'unknown' {
  const normalized = (mimeType ?? '').toLowerCase()
  const name = filename?.toLowerCase() ?? ''
  if (normalized.startsWith('image/') || /\.(jpg|jpeg|png|gif|bmp|webp|svg)$/.test(name)) {
    return 'image'
  }
  if (normalized === 'application/pdf' || name.endsWith('.pdf')) {
    return 'pdf'
  }
  if (
    normalized === 'application/msword' ||
    normalized === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
    name.endsWith('.doc') ||
    name.endsWith('.docx')
  ) {
    return 'word'
  }
  return 'unknown'
}

function parseConversationAttachments(rawMessages: unknown[]): {
  conversationMessages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }>
  imageAttachments: ImageAttachment[]
  documentAttachments: DocumentAttachment[]
} {
  const conversationMessages: Array<{ role: 'system' | 'user' | 'assistant'; content: string }> = []
  const imageAttachments: ImageAttachment[] = []
  const documentAttachments: DocumentAttachment[] = []

  for (const raw of rawMessages) {
    const message: any = raw
    if (
      !message ||
      typeof message.role !== 'string' ||
      (message.role !== 'system' && message.role !== 'user' && message.role !== 'assistant') ||
      typeof message.content !== 'string'
    ) {
      continue
    }
    const role = message.role as 'system' | 'user' | 'assistant'
    const content = message.content as string
    conversationMessages.push({ role, content })
    const messageIndex = conversationMessages.length - 1

    const attachment = typeof message.attachment === 'object' && message.attachment ? (message.attachment as Record<string, unknown>) : null
    const attachmentData =
      typeof attachment?.dataUrl === 'string'
        ? attachment.dataUrl
        : typeof attachment?.data === 'string'
          ? attachment.data
          : ''
    const attachmentMime = typeof attachment?.mimeType === 'string' ? attachment.mimeType : ''
    const attachmentFilename = typeof attachment?.filename === 'string' ? attachment.filename : undefined
    if (attachmentData) {
      const detectedType = detectAttachmentType(attachmentMime, attachmentFilename)
      if (detectedType === 'image') {
        imageAttachments.push({
          messageIndex,
          imageBase64: attachmentData,
          mimeType: attachmentMime || undefined,
        })
        continue
      }
      if (detectedType === 'pdf' || detectedType === 'word') {
        let normalizedMime = attachmentMime.trim()
        if (!normalizedMime) {
          normalizedMime = detectedType === 'pdf' ? 'application/pdf' : 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        }
        documentAttachments.push({
          messageIndex,
          dataUrl: attachmentData,
          mimeType: normalizedMime,
          filename: attachmentFilename,
          type: detectedType,
        })
        continue
      }
    }

    const imageBase64 = typeof message.imageBase64 === 'string' ? message.imageBase64 : ''
    const imageUrl = typeof message.imageUrl === 'string' ? message.imageUrl : ''
    const mimeType = typeof message.mimeType === 'string' ? message.mimeType : ''
    if (imageBase64 || imageUrl) {
      const attachmentRecord: ImageAttachment & { imageBase64?: string; imageUrl?: string; mimeType?: string } = {
        messageIndex,
      }
      if (imageBase64) attachmentRecord.imageBase64 = imageBase64
      if (imageUrl) attachmentRecord.imageUrl = imageUrl
      if (mimeType) attachmentRecord.mimeType = mimeType
      imageAttachments.push(attachmentRecord)
    }
  }

  return { conversationMessages, imageAttachments, documentAttachments }
}

async function executeToolCall(
  call: ChatToolCall,
  context: {
    modelTier: 'standard' | 'pro' | null
    userQuestion?: string | undefined
    imageAttachment?: ImageAttachment | null | undefined
    enableSearch?: boolean | undefined
    language?: LanguageCode | undefined
  } = {
    modelTier: null,
  },
): Promise<{
  log: ToolExecutionLog
  snapshot?: SmartHomeSnapshot
  directResponse?: string
}> {
  const language = context.language ?? getPreferredLanguage()
  switch (call.tool) {
    case 'updateSettings': {
      const startedAt = Date.now()
      if (!call.args || typeof call.args !== 'object') {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'Invalid settings payload.',
            args: call.args,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      const allowedKeys: Array<keyof SmartHomeSettings> = [
        'autoMode',
        'targetTemperatureC',
        'targetHumidityPercent',
        'waterBowlLevelTargetMl',
        'feederSchedule',
        'purifierIntensity',
      ]

      const partial: Partial<SmartHomeSettings> = {}
      for (const key of allowedKeys) {
        if (Object.prototype.hasOwnProperty.call(call.args, key)) {
          ;(partial as any)[key] = (call.args as any)[key]
        }
      }

      if (Object.keys(partial).length === 0) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'No supported settings provided.',
            args: call.args,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      const previousSettings = { ...currentSettings }
      const merged = { ...currentSettings, ...partial }

      if (merged.targetTemperatureC < 16 || merged.targetTemperatureC > 36) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'targetTemperatureC out of safe range.',
            args: partial,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      if (merged.targetHumidityPercent < 20 || merged.targetHumidityPercent > 80) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'targetHumidityPercent out of safe range.',
            args: partial,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      if (merged.waterBowlLevelTargetMl < 80 || merged.waterBowlLevelTargetMl > 500) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'waterBowlLevelTargetMl out of bounds.',
            args: partial,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      if (
        typeof merged.feederSchedule === 'string' &&
        !/^\d{2}:\d{2}(,\s*\d{2}:\d{2})*$/.test(merged.feederSchedule)
      ) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'feederSchedule format invalid.',
            args: partial,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      if (!isSmartHomeSettings(merged)) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'Settings validation failed.',
            args: partial,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      await applySettings(merged)
      recordSettingsMemory(previousSettings, currentSettings, 'tool:updateSettings')
      const result: { log: ToolExecutionLog; snapshot?: SmartHomeSnapshot } = {
        log: {
          tool: call.tool,
          success: true,
          message: 'Settings updated successfully.',
          args: partial,
          durationMs: Date.now() - startedAt,
        },
      }

      if (latestSnapshot) {
        result.snapshot = latestSnapshot
      }

      return result
    }
    case 'updateCalibration': {
      const startedAt = Date.now()
      const previousCalibration = currentCalibration ? { ...currentCalibration } : null
      const normalized = normalizeCalibrationPayload(call.args)
      if (!normalized) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'Calibration payload invalid.',
            args: call.args,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      if (!normalized.changed) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'No calibration updates were provided.',
            args: call.args,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      currentCalibration = normalized.profile
      saveCalibration(normalized.profile)
      pushCalibrationToHardware(normalized.profile)
      recordCalibrationMemory(previousCalibration, normalized.profile, 'tool:updateCalibration')
      const summary = summarizeCalibrationAdjustment(getPreferredLanguage(), previousCalibration, normalized.profile)
      return {
        log: {
          tool: call.tool,
          success: true,
          message: 'Calibration updated successfully.',
          args: normalized.profile,
          durationMs: Date.now() - startedAt,
          ...(summary ? { output: summary } : {}),
        },
      }
    }
    case 'analyzeImage': {
      const startedAt = Date.now()
      const attachment = context.imageAttachment
      const rawArgs = (call.args && typeof call.args === 'object') ? (call.args as Record<string, unknown>) : {}
      const providedBase64 =
        typeof rawArgs.imageBase64 === 'string' && rawArgs.imageBase64.trim().length > 0
          ? rawArgs.imageBase64.trim()
          : attachment?.imageBase64
      const providedUrl =
        typeof rawArgs.imageUrl === 'string' && rawArgs.imageUrl.trim().length > 0
          ? rawArgs.imageUrl.trim()
          : attachment?.imageUrl
      const mimeType =
        typeof rawArgs.mimeType === 'string' && rawArgs.mimeType.trim().length > 0
          ? rawArgs.mimeType.trim()
          : attachment?.mimeType
      if (!providedBase64 && !providedUrl) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: getPreferredLanguage() === 'en' ? 'No image data available for analysis.' : 'æ²’æœ‰å¯ç”¨çš„å½±åƒè³‡æ–™å¯ä»¥åˆ†æžã€‚',
            args: rawArgs,
            durationMs: Date.now() - startedAt,
            errorCode: 'missing_image',
          },
        }
      }
      const prompt =
        typeof rawArgs.prompt === 'string' && rawArgs.prompt.trim().length > 0
          ? rawArgs.prompt
          : context.userQuestion
      try {
        const visionSummary = await analyzeImageWithQwen({
          imageBase64: providedBase64,
          imageUrl: providedUrl,
          mimeType,
          prompt,
          language: getPreferredLanguage(),
        })
        const result: {
          log: ToolExecutionLog
          directResponse?: string
        } = {
          log: {
            tool: call.tool,
            success: true,
            message: getPreferredLanguage() === 'en' ? 'Image analysed successfully.' : 'å½±åƒåˆ†æžå®Œæˆã€‚',
            args: prompt ? { prompt } : undefined,
            durationMs: Date.now() - startedAt,
            output: visionSummary.text,
          },
        }
        if (visionSummary.catVisible === false) {
          result.directResponse =
            getPreferredLanguage() === 'en'
              ? "I reviewed the photo but couldnâ€™t actually see your catâ€”could you try another angle or describe the situation so I can help?"
              : 'æˆ‘çœ‹éŽé€™å¼µç…§ç‰‡ï¼Œä½†ç•«é¢è£¡çœ‹ä¸åˆ°è²“å’ªã€‚å¯ä»¥æ›å€‹è§’åº¦å†æ‹ä¸€æ¬¡ï¼Œæˆ–ç›´æŽ¥ç”¨æ–‡å­—æè¿°ç‹€æ³ï¼Œè®“æˆ‘å¥½å¹«ä¸Šå¿™å—Žï¼Ÿ'
        }
        // ðŸ” DEBUG: Log vision analysis result
        console.log('[VISION DEBUG] analyzeImage result:', {
          catVisible: visionSummary.catVisible,
          textLength: visionSummary.text?.length || 0,
          textPreview: visionSummary.text?.substring(0, 100) + '...',
          hasDirectResponse: !!result.directResponse
        })
        return result
      } catch (error) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: error instanceof Error ? error.message : 'Vision analysis failed.',
            args: prompt ? { prompt } : undefined,
            durationMs: Date.now() - startedAt,
            errorCode: 'vision_failed',
          },
        }
      }
    }
    case 'createCareTask': {
      const startedAt = Date.now()
      const normalized = normalizeTaskToolPayload(call.args)
      if (!normalized.ok) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: normalized.message,
            args: call.args,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      try {
        const created = createCareTask({
          title: normalized.payload.title,
          description: normalized.payload.description,
          category: normalized.payload.category,
          dueAt: normalized.payload.dueAt,
          metadata: normalized.payload.metadata,
          source: 'ai',
        })
        const successMessage = getPreferredLanguage() === 'en' ? 'Task created successfully.' : 'å·²å»ºç«‹ç…§è­·ä»»å‹™ã€‚'
        return {
          log: {
            tool: call.tool,
            success: true,
            message: successMessage,
            args: {
              title: created.title,
              category: created.category,
              dueAt: created.dueAt,
            },
            durationMs: Date.now() - startedAt,
            output: `Task #${created.id}: ${created.title}`,
          },
        }
      } catch (error) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: error instanceof Error ? error.message : 'task-create-failed',
            args: normalized.payload,
            durationMs: Date.now() - startedAt,
          },
        }
      }
    }
    case 'switchToProModel': {
      const startedAt = Date.now()
      const reason =
        call.args && typeof call.args === 'object' && (call.args as { reason?: unknown }).reason
          ? String((call.args as { reason?: unknown }).reason)
          : null
      return {
        log: {
          tool: call.tool,
          success: true,
          message:
            getPreferredLanguage() === 'en'
              ? 'Preparing to switch to pro-tier reasoning.'
              : 'æº–å‚™åˆ‡æ›è‡³ Pro æ¨¡åž‹ã€‚',
          args: reason ? { reason } : undefined,
          durationMs: Date.now() - startedAt,
        },
      }
    }
    case 'playAudioPattern': {
      const startedAt = Date.now()
      const args = (call.args && typeof call.args === 'object' ? (call.args as Record<string, unknown>) : {}) ?? {}
      const ALLOWED_PATTERNS = new Set([
        'call-cat',
        'wake-up-lullaby',
        'hydrate-reminder',
        'meow-call',
        'calm-chime',
        'alert',
      ])
      const requestedPattern = typeof args.pattern === 'string' ? args.pattern.trim() : ''
      const pattern = ALLOWED_PATTERNS.has(requestedPattern) ? requestedPattern : 'call-cat'
      const repeatRaw =
        typeof args.repeat === 'number'
          ? args.repeat
          : typeof args.repeat === 'string'
            ? Number.parseInt(args.repeat, 10)
            : undefined
      const repeat = repeatRaw && Number.isFinite(repeatRaw) ? Math.min(5, Math.max(1, Math.trunc(repeatRaw))) : 1
      const volumeRaw =
        typeof args.volumePercent === 'number'
          ? args.volumePercent
          : typeof args.volumePercent === 'string'
            ? Number.parseFloat(args.volumePercent)
            : undefined
      const volume =
        typeof volumeRaw === 'number' && Number.isFinite(volumeRaw) ? Math.min(100, Math.max(0, volumeRaw)) : undefined
      const mute = typeof args.mute === 'boolean' ? args.mute : undefined

      if (typeof volume !== 'undefined' || typeof mute !== 'undefined') {
        updateAudioConfiguration({
          volumePercent: volume,
          muted: mute,
        })
      }

      triggerAudioPattern(pattern, repeat)
      const summary = latestAudioStatus
        ? `pattern=${latestAudioStatus.activePattern}, volume=${latestAudioStatus.volumePercent}%, playing=${latestAudioStatus.playing}`
        : 'Audio command dispatched.'

      return {
        log: {
          tool: call.tool,
          success: true,
          message:
            getPreferredLanguage() === 'en'
              ? `Playing audio pattern "${pattern}" ${repeat} time(s).`
              : `å·²æ’­æ”¾éŸ³è¨Šæ¨¡å¼ã€Œ${pattern}ã€ï¼Œé‡è¤‡ ${repeat} æ¬¡ã€‚`,
          args: {
            pattern,
            repeat,
            ...(typeof volume !== 'undefined' ? { volumePercent: volume } : {}),
            ...(typeof mute !== 'undefined' ? { mute } : {}),
          },
          durationMs: Date.now() - startedAt,
          output: summary,
        },
      }
    }
    case 'stopAudioPlayback': {
      const startedAt = Date.now()
      const mute = call.args && typeof call.args === 'object' && typeof (call.args as any).mute === 'boolean'
        ? Boolean((call.args as any).mute)
        : undefined

      stopAudioPlayback()
      if (typeof mute !== 'undefined') {
        updateAudioConfiguration({ muted: mute })
      }

      const summary = latestAudioStatus
        ? `pattern=${latestAudioStatus.activePattern}, playing=${latestAudioStatus.playing}`
        : 'Playback stop issued.'

      return {
        log: {
          tool: call.tool,
          success: true,
          message:
            getPreferredLanguage() === 'en'
              ? 'Audio playback stopped.'
              : 'éŸ³è¨Šæ’­æ”¾å·²åœæ­¢ã€‚',
          args: typeof mute !== 'undefined' ? { mute } : undefined,
          durationMs: Date.now() - startedAt,
          output: summary,
        },
      }
    }
    case 'refreshCameraStatus': {
      const startedAt = Date.now()
      const args = (call.args && typeof call.args === 'object' ? (call.args as Record<string, unknown>) : {}) ?? {}
      const captureSnapshot = args.captureSnapshot === true
      const reason = typeof args.reason === 'string' ? args.reason.trim() : null
      try {
        const status = await pollCameraStatus()
        if (!status) {
          return {
            log: {
              tool: call.tool,
              success: false,
              message:
                getPreferredLanguage() === 'en'
                  ? 'Camera did not respond.'
                  : 'æ”å½±æ©Ÿæ²’æœ‰å›žæ‡‰ã€‚',
              args: { captureSnapshot, reason },
              durationMs: Date.now() - startedAt,
            },
          }
        }
        patchLatestVisionStatus(status)
        let snapshotNote: string | undefined
        if (captureSnapshot) {
          const snapshot = await fetchCameraSnapshotBuffer()
          if (snapshot) {
            patchLatestVisionStatus(getCameraRuntime())
            snapshotNote = `Snapshot refreshed (${snapshot.contentType}, ${snapshot.buffer.length} bytes)`
          } else {
            snapshotNote = 'Snapshot unavailable'
          }
        }
        const runtime = getCameraRuntime()
        const inference = runtime?.inference
        const summary = inference
          ? `catDetected=${inference.catDetected ? 'yes' : 'no'}, confidence=${Math.round(inference.probability * 100)}%`
          : 'No inference data yet.'

        return {
          log: {
            tool: call.tool,
            success: true,
            message:
              getPreferredLanguage() === 'en'
                ? 'Camera status refreshed.'
                : 'æ”å½±æ©Ÿç‹€æ…‹å·²æ›´æ–°ã€‚',
            args: { captureSnapshot, reason },
            durationMs: Date.now() - startedAt,
            output: snapshotNote ? `${summary} Â· ${snapshotNote}` : summary,
          },
        }
      } catch (error) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message:
              getPreferredLanguage() === 'en'
                ? `Camera refresh failed: ${safeErrorMessage(error)}`
                : `æ”å½±æ©Ÿæ›´æ–°å¤±æ•—ï¼š${safeErrorMessage(error)}`,
            args: { captureSnapshot, reason },
            durationMs: Date.now() - startedAt,
          },
        }
      }
    }
    case 'searchWeb':
    case 'mcp.browser.search': {
      const startedAt = Date.now()
      const language = context.language ?? getPreferredLanguage()
      if (context.enableSearch === false) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message:
              language === 'en'
                ? 'Web search is disabled for this request.'
                : 'æœ¬æ¬¡è«‹æ±‚å·²åœç”¨ç¶²é æœå°‹ã€‚',
            args: call.args,
            durationMs: Date.now() - startedAt,
            errorCode: 'search_disabled',
          },
        }
      }
      const args = (call.args && typeof call.args === 'object') ? (call.args as Record<string, unknown>) : {}
      const queryRaw = typeof args.query === 'string' ? args.query : typeof args.q === 'string' ? args.q : ''
      const query = queryRaw.trim().slice(0, 200)
      if (!query) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: language === 'en' ? 'Query text is required.' : 'è«‹æä¾›è¦æœå°‹çš„é—œéµå­—ã€‚',
            args,
            durationMs: Date.now() - startedAt,
            errorCode: 'missing_query',
          },
        }
      }
      if (!SEARCH_PROXY_URL) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: language === 'en' ? 'Search proxy not configured.' : 'å°šæœªè¨­å®šæœå°‹ä»£ç†ã€‚',
            args: { query },
            durationMs: Date.now() - startedAt,
            errorCode: 'proxy_missing',
          },
        }
      }

      const limitRaw = typeof args.limit === 'number' && Number.isFinite(args.limit) ? args.limit : undefined
      const limit = limitRaw !== undefined ? Math.max(1, Math.min(Math.trunc(limitRaw), 5)) : 3
      const proxyUrl = new URL(SEARCH_PROXY_URL)
      proxyUrl.searchParams.set('q', query)
      proxyUrl.searchParams.set('limit', String(limit))
      const langArg =
        typeof args.lang === 'string' && args.lang.trim().length > 0
          ? args.lang.trim().slice(0, 5)
          : language
      proxyUrl.searchParams.set('lang', langArg)

      try {
        const controller = new AbortController()
        const timeout = setTimeout(() => controller.abort(), SEARCH_PROXY_TIMEOUT_MS)
        let payload: any = null
        let responseText = ''
        try {
          const response = await fetch(proxyUrl.toString(), {
            method: 'GET',
            headers: { Accept: 'application/json' },
            signal: controller.signal,
          })
          responseText = await response.text()
          if (!response.ok) {
            throw new Error(responseText || `HTTP ${response.status}`)
          }
          try {
            payload = JSON.parse(responseText)
          } catch {
            payload = null
          }
        } finally {
          clearTimeout(timeout)
        }

        const lines: string[] = []
        const rows: Array<{ title?: string; url?: string; snippet?: string }> = Array.isArray(payload?.results)
          ? payload.results
          : Array.isArray(payload)
            ? payload
            : []
        const sliced = rows.slice(0, limit)
        if (sliced.length > 0) {
          sliced.forEach((item, index) => {
            const title = (item?.title || item?.url || `Result ${index + 1}`).toString().trim()
            const url = (item?.url || '').toString().trim()
            const snippet = (item?.snippet || '').toString().trim()
            let block = `${index + 1}. ${title}`
            if (snippet) block += `\n${snippet}`
            if (url) block += `\n${url}`
            lines.push(block)
          })
        }

        const summary =
          lines.length > 0
            ? lines.join('\n\n')
            : responseText
                .split('\n')
                .map((line) => line.trim())
                .filter(Boolean)
                .slice(0, limit)
                .join('\n')

        if (!summary.trim()) {
          return {
            log: {
              tool: call.tool,
              success: false,
              message: language === 'en' ? 'Search returned no readable summary.' : 'æœå°‹çµæžœç‚ºç©ºã€‚',
              args: { query },
              durationMs: Date.now() - startedAt,
              errorCode: 'empty_results',
            },
          }
        }

        return {
          log: {
            tool: call.tool,
            success: true,
            message:
              language === 'en'
                ? `Fetched ${lines.length || 1} search result(s).`
                : `å–å¾— ${lines.length || 1} ç­†æœå°‹çµæžœã€‚`,
            args: { query, lang: langArg, limit },
            durationMs: Date.now() - startedAt,
            output: summary,
          },
        }
      } catch (error) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: error instanceof Error ? error.message : 'Search request failed.',
            args: { query },
            durationMs: Date.now() - startedAt,
            errorCode: 'search_failed',
          },
        }
      }
    }
    case 'saveMemory': {
      const startedAt = Date.now()
      if (!call.args || typeof call.args !== 'object') {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'Memory payload missing.',
            args: call.args,
            durationMs: Date.now() - startedAt,
          },
        }
      }

      const payload = call.args as { type?: unknown; content?: unknown; source?: unknown }
      const rawContent = typeof payload.content === 'string' ? payload.content.trim() : ''
      const requestedType =
        typeof payload.type === 'string' ? payload.type.trim().toLowerCase() : ''
      const memoryType: MemoryType = isMemoryType(requestedType) ? (requestedType as MemoryType) : 'note'
      const source =
        typeof payload.source === 'string' && payload.source.trim().length > 0
          ? payload.source.trim()
          : 'tool:saveMemory'

      if (rawContent.length < 3) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message: 'Memory content too short.',
            args: { type: memoryType, content: rawContent },
            durationMs: Date.now() - startedAt,
          },
        }
      }

      try {
        const entry = addMemory({
          type: memoryType,
          content: rawContent.slice(0, 1000),
          source,
        })

        const summary =
          entry.content.length > 200 ? `${entry.content.slice(0, 197)}â€¦` : entry.content

        return {
          log: {
            tool: call.tool,
            success: true,
            message: 'Memory saved successfully.',
            args: { id: entry.id, type: entry.type, source },
            durationMs: Date.now() - startedAt,
            output: summary,
          },
        }
      } catch (error) {
        return {
          log: {
            tool: call.tool,
            success: false,
            message:
              error instanceof Error ? error.message : 'Failed to persist memory entry.',
            args: { type: memoryType, content: rawContent, source },
            durationMs: Date.now() - startedAt,
          },
        }
      }
    }
    default: {
      if (isMcpTool(call.tool)) {
        const startedAt = Date.now()
        try {
          const result = await executeMcpTool(call.tool, call.args ?? {})
          return {
            log: {
              tool: call.tool,
              success: true,
              message: 'MCP tool executed successfully.',
              args: call.args,
              durationMs: Date.now() - startedAt,
              output: result.output,
            },
          }
        } catch (error) {
          return {
            log: {
              tool: call.tool,
              success: false,
              message: error instanceof Error ? error.message : 'MCP tool execution failed.',
              args: call.args,
              durationMs: Date.now() - startedAt,
              errorCode: 'mcp_error',
            },
          }
        }
      }
      return {
        log: {
          tool: call.tool,
          success: false,
          message: 'Unsupported tool.',
        },
      }
    }
  }
}

async function analyzeImageAttachmentsBeforeChat(params: {
  attachments: ImageAttachment[]
  question: string
  language: LanguageCode
  toolEvents: ToolExecutionLog[]
  connection?: SSEConnection | null
}): Promise<{ summary: string | null; directResponse?: string }> {
  const { attachments, question, language, toolEvents, connection } = params
  if (!attachments.length) {
    return { summary: null }
  }

  const summaries: string[] = []
  for (const attachment of attachments) {
    const call: ChatToolCall = {
      tool: 'analyzeImage',
      args: question ? { prompt: question } : {},
    }
    const execution = await executeToolCall(call, {
      modelTier: null,
      userQuestion: question,
      imageAttachment: attachment,
    })
    toolEvents.push(execution.log)
    recordToolEvent(execution.log)
    connection?.sendTool(call.tool, call.args, execution.log)

    if (execution.directResponse) {
      console.log('[VISION DEBUG] executeToolCall returned directResponse:', {
        responseLength: execution.directResponse.length,
        responsePreview: execution.directResponse.substring(0, 100) + '...'
      })
      return { summary: null, directResponse: execution.directResponse }
    }

    if (!execution.log.success) {
      // ðŸš« CRITICAL: When vision fails, provide clear fallback and stop the chat generation
      // This prevents the chat model from hallucinating about the image
      const fallback =
        language === 'en'
          ? `âš ï¸ Vision Analysis Failed

I cannot analyze the photo because the vision model is not responding properly.

**Error:** ${execution.log.message}

**What you can do:**
1. Describe what you see in the photo manually
2. Try uploading the photo again
3. Check if the vision service is running (port 18183)

Without vision analysis, I cannot comment on the image content. I'm here to help with sensor data and text-based questions in the meantime.`
          : `âš ï¸ è¦–è¦ºåˆ†æžå¤±æ•—

æˆ‘ç„¡æ³•åˆ†æžç…§ç‰‡ï¼Œå› ç‚ºè¦–è¦ºæ¨¡åž‹æ²’æœ‰æ­£å¸¸å›žæ‡‰ã€‚

**éŒ¯èª¤ï¼š** ${execution.log.message}

**æ‚¨å¯ä»¥ï¼š**
1. æ‰‹å‹•æè¿°æ‚¨åœ¨ç…§ç‰‡ä¸­çœ‹åˆ°çš„å…§å®¹
2. é‡æ–°ä¸Šå‚³ç…§ç‰‡
3. æª¢æŸ¥è¦–è¦ºæœå‹™æ˜¯å¦é‹è¡Œä¸­ï¼ˆç«¯å£ 18183ï¼‰

æ²’æœ‰è¦–è¦ºåˆ†æžï¼Œæˆ‘ç„¡æ³•è©•è«–åœ–ç‰‡å…§å®¹ã€‚ä½†æˆ‘å¯ä»¥å”åŠ©æ„Ÿæ¸¬å™¨æ•¸æ“šå’Œæ–‡å­—å•é¡Œã€‚`
      return { summary: null, directResponse: fallback }
    }

    if (execution.log.output?.trim()) {
      summaries.push(execution.log.output.trim())
    } else if (execution.log.success) {
      // ðŸš« CRITICAL: Vision succeeded but returned empty content (catVisible: false or no summary)
      // This means the vision model couldn't see the cat or analyze the image properly
      const fallback =
        language === 'en'
          ? `âš ï¸ Image Analysis Incomplete

I received a response from the vision model, but it couldn't detect a cat or provide useful analysis from the image.

**Possible reasons:**
- The image doesn't contain a cat
- The image quality is too low or unclear
- The image is corrupted or invalid

**What you can do:**
1. Verify the image contains a cat
2. Try a clearer, well-lit photo
3. Describe what you see in the image manually

I'm here to help with sensor data and text-based questions.`
          : `âš ï¸ åœ–åƒåˆ†æžä¸å®Œæ•´

æˆ‘æ”¶åˆ°äº†è¦–è¦ºæ¨¡åž‹çš„å›žæ‡‰ï¼Œä½†å®ƒç„¡æ³•åµæ¸¬åˆ°è²“å’ªæˆ–æä¾›æœ‰ç”¨çš„åˆ†æžã€‚

**å¯èƒ½åŽŸå› ï¼š**
- åœ–ç‰‡ä¸­æ²’æœ‰è²“å’ª
- åœ–ç‰‡å“è³ªå¤ªä½Žæˆ–ä¸æ¸…æ¥š
- åœ–ç‰‡æå£žæˆ–ç„¡æ•ˆ

**æ‚¨å¯ä»¥ï¼š**
1. ç¢ºèªåœ–ç‰‡ä¸­ç¢ºå¯¦æœ‰è²“å’ª
2. å˜—è©¦æ›´æ¸…æ™°ã€å…‰ç·šå……è¶³çš„ç…§ç‰‡
3. æ‰‹å‹•æè¿°æ‚¨åœ¨åœ–ç‰‡ä¸­çœ‹åˆ°çš„å…§å®¹

æˆ‘éš¨æ™‚å¯ä»¥å”åŠ©æ„Ÿæ¸¬å™¨æ•¸æ“šå’Œæ–‡å­—å•é¡Œã€‚`
      return { summary: null, directResponse: fallback }
    }
  }

  return {
    summary: summaries.length ? summaries.join('\n\n---\n\n') : null,
  }
}

function buildToolResultPrompt(log: ToolExecutionLog, language: LanguageCode) {
  const outputLine = log.output?.trim()

  if (language === 'en') {
    if (log.tool === 'analyzeImage') {
      const summary = outputLine || 'Vision summary unavailable.'
      return log.success
        ? `Vision tool completed. Only rely on this summary when describing the photo:\n${summary}\nIf the summary says the cat is missing, unclear, or the frame is invalid, explicitly say you could not see the cat and ask for another description or image. Never invent posture, lighting, or objects that are not listed above. Tie these vision notes back to sensor data for warm, practical guidance.`
        : `Vision analysis failed: ${log.message}.${outputLine ? ` Details:\n${outputLine}` : ''} Apologise, explain you will fall back to sensors/text only, and invite the user to provide a clearer photo or describe the scene manually.`
    }

    if (log.tool === 'analyzeDocument') {
      const summary = outputLine || 'Document summary unavailable.'
      return log.success
        ? `${summary}\nUse this document overview when responding. Mention that you reviewed the uploaded document, highlight the most relevant finding, and tie it back to the userâ€™s current question checking for consistency.`
        : `Document analysis failed: ${log.message}.${outputLine ? ` Details:\n${outputLine}` : ''} Explain you read the document but encountered an error, and proceed with sensor/text data instead.`
    }

    if (log.tool === 'createCareTask') {
      return log.success
        ? `Care task created successfully. Summarise what was scheduled (title, category, timing) and invite the user to tick it off once completed.`
        : `Task creation failed: ${log.message}.${outputLine ? ` Details:\n${outputLine}` : ''} Explain what went wrong and propose adding the reminder manually.`
    }

    if (log.tool === 'switchToProModel') {
      return log.success
        ? `Pro model engaged. Let the user know youâ€™re switching to the higher-tier reasoning engine, briefly explain why itâ€™s helpful here, and confirm youâ€™ll continue with the upgraded model.`
        : `Switching to the pro model failed: ${log.message}.${outputLine ? ` Details:\n${outputLine}` : ''} Reassure the user youâ€™ll continue with the standard model and invite them to proceed.`
    }

    if (log.tool === 'searchWeb') {
      const prefix = log.message ? `${log.message}\n` : ''
      return log.success
        ? `${prefix}Here are curated search findings. Present them as a numbered list â€” for each result name the source, highlight the key feline-care insight, and state one concrete action the user can try. Call out any result you discarded for safety or relevance. After the list, connect those ideas back to the userâ€™s current data or routines and invite them to follow up if they want deeper guidance. End with a reminder that online sources may be incomplete and that youâ€™ll prioritise local sensor facts if conflicts arise.\n${outputLine ?? 'No summaries available.'}`
        : `Web search failed: ${log.message}.${outputLine ? ` Details:\n${outputLine}` : ''} Tell the user why it was blocked (safety rules, missing cat-care context, or network issues), remind them to enable search and switch to the pro model if needed, and suggest manual follow-ups or alternative steps grounded in existing data.`
    }

    return log.success
      ? `Tool ${log.tool} executed successfully. Result: ${log.message}.${outputLine ? ` Summary:\n${outputLine}` : ''} Summarise this outcome for the user, extend it with next steps, and keep the tone supportive.`
      : `Tool ${log.tool} failed. Reason: ${log.message}.${outputLine ? ` Details:\n${outputLine}` : ''} Explain the issue to the user and suggest a manual follow-up.`
  }

  if (log.tool === 'analyzeImage') {
    const summary = outputLine || 'ç„¡è¦–è¦ºæ‘˜è¦'
    return log.success
      ? `è¦–è¦ºå·¥å…·å®Œæˆï¼Œä»¥ä¸‹æ˜¯æ‘˜è¦ï¼Œæè¿°ç…§ç‰‡æ™‚åªèƒ½å¼•ç”¨é€™äº›è³‡è¨Šï¼š\n${summary}\nè‹¥æ‘˜è¦æŒ‡å‡ºæ²’çœ‹åˆ°è²“å’ªã€ç•«é¢æ¨¡ç³Šæˆ–å…§å®¹ç„¡æ³•è¾¨è­˜ï¼Œè«‹ç›´æŽ¥èªªã€Œçœ‹ä¸æ¸…æ¥šã€ï¼Œä¸¦è«‹ä½¿ç”¨è€…å†æä¾›ç…§ç‰‡æˆ–æ”¹ç”¨æ–‡å­—ï¼Œçµ•å°ä¸è¦æé€ è²“å’ªçš„å§¿å‹¢ã€ç‡ˆå…‰æˆ–ç‰©ä»¶ã€‚æœ€å¾ŒæŠŠé€™äº›è§€å¯Ÿèˆ‡æ„Ÿæ¸¬æ•¸æ“šçµåˆï¼Œæä¾›æº«æš–åˆå‹™å¯¦çš„ç…§è­·å»ºè­°ã€‚`
      : `å½±åƒåˆ†æžå¤±æ•—ï¼š${log.message}ã€‚${outputLine ? `è©³ç´°è³‡è¨Šï¼š\n${outputLine}\n` : ''}è«‹å‘ä½¿ç”¨è€…è‡´æ­‰ï¼Œèªªæ˜Žæœƒæ”¹ç”¨æ„Ÿæ¸¬è³‡æ–™èˆ‡æ–‡å­—è³‡è¨Šï¼Œä¸¦é‚€è«‹å°æ–¹æ›ä¸€å¼µæ›´æ¸…æ¥šçš„ç…§ç‰‡æˆ–ç›´æŽ¥æè¿°ç‹€æ³ã€‚`
  }

  if (log.tool === 'analyzeDocument') {
    const summary = outputLine || 'ç„¡æ–‡ä»¶æ‘˜è¦'
    return log.success
      ? `æ–‡ä»¶åˆ†æžå®Œæˆï¼Œä»¥ä¸‹æ˜¯é‡é»žæ‘˜è¦ï¼š\n${summary}\nè«‹èªªæ˜Žä½ å·²é–±è®€è©²æ–‡ä»¶ï¼Œä¸¦å°‡æ‘˜è¦ä¸­æœ€ç›¸é—œçš„å…§å®¹èˆ‡ä½¿ç”¨è€…æå•é€£çµï¼Œç¢ºèªæ˜¯å¦éœ€ä¾æ“šæ–‡ä»¶é€²è¡Œèª¿æ•´ã€‚`
      : `æ–‡ä»¶åˆ†æžå¤±æ•—ï¼š${log.message}ã€‚${outputLine ? `è©³ç´°è³‡è¨Šï¼š\n${outputLine}\n` : ''}è«‹å‘ŠçŸ¥ä½¿ç”¨è€…ç„¡æ³•è®€å–è©²æ–‡ä»¶ï¼Œä¸¦æ”¹å¾žæ„Ÿæ¸¬æˆ–æ–‡å­—è³‡æ–™å›žæ‡‰ã€‚`
  }

  if (log.tool === 'createCareTask') {
    return log.success
      ? `å·²å»ºç«‹ç…§è­·ä»»å‹™ã€‚è«‹å‘ä½¿ç”¨è€…èªªæ˜Žä»»å‹™å…§å®¹ï¼ˆåç¨±ã€é¡žåˆ¥ã€é å®šæ™‚é–“ï¼‰ï¼Œä¸¦æé†’å®Œæˆå¾Œè¨˜å¾—å‹¾é¸ã€‚`
      : `å»ºç«‹ç…§è­·ä»»å‹™å¤±æ•—ï¼ŒåŽŸå› ï¼š${log.message}ã€‚${outputLine ? `è©³ç´°è³‡è¨Šï¼š\n${outputLine}\n` : ''}è«‹å»ºè­°ä½¿ç”¨è€…æ”¹ä»¥æ‰‹å‹•æ–¹å¼è¨˜ä¸‹æé†’ã€‚`
  }

  if (log.tool === 'switchToProModel') {
    return log.success
      ? `å·²åˆ‡æ›è‡³ Pro æ¨¡åž‹ã€‚è«‹å‘ŠçŸ¥ä½¿ç”¨è€…æˆ‘å€‘æœƒæ”¹ç”¨è¼ƒé«˜éšŽçš„æŽ¨ç†èƒ½åŠ›ï¼Œç°¡è¿°é€™éº¼åšçš„ç†ç”±ï¼Œä¸¦ç¢ºèªæŽ¥ä¸‹ä¾†çš„å›žè¦†å°‡ä»¥ Pro æ¨¡åž‹æä¾›ã€‚`
      : `åˆ‡æ› Pro æ¨¡åž‹å¤±æ•—ï¼ŒåŽŸå› ï¼š${log.message}ã€‚${outputLine ? `è©³ç´°è³‡è¨Šï¼š\n${outputLine}\n` : ''}è«‹å®‰æ’«ä½¿ç”¨è€…ä»æœƒä»¥æ¨™æº–æ¨¡åž‹ç¹¼çºŒæœå‹™ï¼Œä¸¦é‚€è«‹å°æ–¹æŒçºŒå°è©±ã€‚`
  }

  if (log.tool === 'searchWeb') {
    const prefix = log.message ? `${log.message}\n` : ''
    return log.success
      ? `${prefix}è«‹ç”¨æ¢åˆ—æ–¹å¼é€é …èªªæ˜Žæœå°‹çµæžœï¼šæ¯ä¸€é»žéƒ½è¦å¯«å‡ºä¾†æºåç¨±ã€å­¸åˆ°çš„ç…§è­·é‡é»žï¼Œä¸¦æä¾›ä¸€å€‹å¯ç«‹å³æŽ¡å–çš„è¡Œå‹•ã€‚è‹¥æœ‰å› å®‰å…¨æˆ–ç„¡é—œè€ŒæŽ’é™¤çš„çµæžœï¼Œè¦æ˜Žç¢ºèªªæ˜Žã€‚åˆ—å®Œå¾Œï¼ŒæŠŠé€™äº›å»ºè­°å’Œä½¿ç”¨è€…ç›®å‰çš„æ„Ÿæ¸¬æ•¸æ“šæˆ–æ—¥å¸¸ç¿’æ…£ä¸²é€£èµ·ä¾†ï¼Œæé†’å¤–éƒ¨è³‡è¨Šå¯èƒ½ä¸å®Œæ•´ï¼Œè‹¥èˆ‡æœ¬æ©Ÿæ„Ÿæ¸¬æˆ–ç´€éŒ„è¡çªæ™‚è¦ä»¥æœ¬æ©Ÿè³‡æ–™ç‚ºæº–ï¼Œæœ€å¾Œå†é‚€è«‹å°æ–¹å‘Šè¨´ä½ æ˜¯å¦éœ€è¦æ›´æ·±å…¥çš„å”åŠ©ã€‚\n${outputLine ?? 'ç„¡æ‘˜è¦'}`
      : `æœå°‹å¤±æ•—ï¼ŒåŽŸå› ï¼š${log.message}ã€‚${outputLine ? `è©³ç´°è³‡è¨Šï¼š\n${outputLine}\n` : ''}è«‹å‘ŠçŸ¥ä½¿ç”¨è€…å—é™åŽŸå› ï¼ˆä¾‹å¦‚å®‰å…¨è¦å‰‡ã€ç¼ºå°‘è²“å’ªç…§è­·èªžå¢ƒæˆ–ç¶²è·¯å•é¡Œï¼‰ï¼Œæé†’è‹¥è¦æœå°‹éœ€é–‹å•Ÿæœå°‹æ¨¡å¼ä¸¦åˆ‡æ›åˆ° Pro æ¨¡åž‹ï¼Œä¸¦æå‡ºå…¶å®ƒå¯è¡Œçš„æŸ¥è©¢æ–¹å¼æˆ–æ ¹æ“šç¾æœ‰è³‡æ–™é€²è¡Œçš„æ‰‹å‹•èª¿æŸ¥å»ºè­°ã€‚`
  }

  return log.success
    ? `å·¥å…· ${log.tool} åŸ·è¡ŒæˆåŠŸï¼Œçµæžœï¼š${log.message}ã€‚${outputLine ? `åˆ†æžæ‘˜è¦ï¼š\n${outputLine}\n` : ''}è«‹å‘ä½¿ç”¨è€…èªªæ˜Žè®Šæ›´ä¸¦æé†’å¾ŒçºŒæ³¨æ„äº‹é …ã€‚`
    : `å·¥å…· ${log.tool} åŸ·è¡Œå¤±æ•—ï¼ŒåŽŸå› ï¼š${log.message}ã€‚${outputLine ? `è©³ç´°è³‡è¨Šï¼š\n${outputLine}\n` : ''}è«‹å‘ä½¿ç”¨è€…æè¿°å•é¡Œä¸¦å»ºè­°å¾ŒçºŒå‹•ä½œã€‚`
}

function ensureFriendlyClosing(text: string, language: LanguageCode) {
  const trimmed = text.trim()
  if (!trimmed) return text

  const closing =
    language === 'en'
      ? 'Let me know if you need anything elseâ€”Iâ€™m right here for you! ðŸ˜Š'
      : 'æœ‰éœ€è¦æˆ‘å°±åœ¨é€™è£¡ï¼Œåˆ¥æ“”å¿ƒï¼ðŸ˜Š'

  const normalized = trimmed.replace(/\s+/g, ' ').toLowerCase()
  const alreadyHasClosing = language === 'en'
    ? normalized.includes('let me know if you need anything else')
    : normalized.includes('æœ‰éœ€è¦æˆ‘å°±åœ¨é€™è£¡')

  if (alreadyHasClosing || trimmed.length > 80) {
    return trimmed
  }

  return `${trimmed}\n\n${closing}`
}

function limitResponseLength(text: string, language: LanguageCode): string {
  const limit = language === 'en' ? 1200 : 900
  const normalized = text.trim()
  if (normalized.length <= limit) {
    return normalized
  }
  const truncated = normalized.slice(0, limit)
  const safe = truncated.replace(/\s+\S*$/, '').trim()
  return safe.length ? `${safe}â€¦` : `${normalized.slice(0, limit)}â€¦`
}

function delay(ms: number) {
  return new Promise<void>((resolve) => {
    setTimeout(resolve, ms)
  })
}

async function notifyAlert(alert: AutomationAlert) {
  if (!pushNotificationsEnabled) return
  const subscriptions = listPushSubscriptions()
  if (!subscriptions.length) return

  const payload = JSON.stringify({
    title: 'Smart Cat Home Alert',
    body: alert.message,
    timestamp: alert.timestamp,
    severity: alert.severity,
  })

  for (let index = 0; index < subscriptions.length; index += PUSH_BATCH_SIZE) {
    const batch = subscriptions.slice(index, index + PUSH_BATCH_SIZE)
    await Promise.all(
      batch.map(async ({ endpoint, subscription }) => {
        try {
          await webPush.sendNotification(subscription as any, payload)
        } catch (error: unknown) {
          const statusCode = (error as { statusCode?: number }).statusCode
          if (statusCode === 404 || statusCode === 410) {
            console.warn('[push] Removing expired subscription', endpoint)
            removePushSubscription(endpoint)
          } else {
            console.warn('[push] Failed to deliver notification', endpoint, error)
          }
        }
      }),
    )
    if (index + PUSH_BATCH_SIZE < subscriptions.length && PUSH_BATCH_DELAY_MS > 0) {
      await delay(PUSH_BATCH_DELAY_MS)
    }
  }
}

if (latestSnapshot && !storedSettings) {
  currentSettings = latestSnapshot.settings
  persistSettings(currentSettings)
}

async function applySettings(next: SmartHomeSettings) {
  const release = await snapshotMutex.acquire()
  try {
    currentSettings = { ...next }
    persistSettings(currentSettings)
    if (latestSnapshot) {
      latestSnapshot = {
        ...latestSnapshot,
        settings: currentSettings,
        status: deriveStatus(latestSnapshot.reading, currentSettings),
      }
      const targetCatId = latestSnapshot.catId ?? activeCatId
      latestSnapshotsByCat.set(targetCatId, latestSnapshot)
      persistSnapshot(latestSnapshot, HISTORY_LIMIT, targetCatId)
    }
    pushSettingsToHardware(currentSettings)
  } finally {
    release()
  }
}

function scheduleBehaviorProfileRefresh(catId: string) {
  const existing = pendingBehaviorRefreshTimers.get(catId)
  if (existing) {
    clearTimeout(existing)
  }
  const handle = setTimeout(() => {
    pendingBehaviorRefreshTimers.delete(catId)
    try {
      refreshBehaviorProfile(catId)
    } catch (error) {
      console.warn('[behavior] Failed to refresh profile for cat', catId, error)
    }
  }, BEHAVIOR_REFRESH_DELAY_MS)
  pendingBehaviorRefreshTimers.set(catId, handle)
}

async function applySnapshot(catId: string, snapshot: SmartHomeSnapshot) {
  const release = await snapshotMutex.acquire()
  try {
    const normalized = snapshot.catId ? snapshot : { ...snapshot, catId }
    latestSnapshotsByCat.set(catId, normalized)
    if (catId === activeCatId) {
      latestSnapshot = normalized
    }
    persistSnapshot(normalized, HISTORY_LIMIT, catId)
    scheduleBehaviorProfileRefresh(catId)
  } finally {
    release()
  }
}

async function handleIncomingReading(catId: string, reading: SmartHomeReading, settingsOverride?: SmartHomeSettings) {
  const previousSnapshot = latestSnapshotsByCat.get(catId) ?? null
  const activeSettings = settingsOverride ?? currentSettings
  const normalized: SmartHomeReading = {
    ...reading,
    timestamp: reading.timestamp,
  }

  if (normalized.audio) {
    normalized.audio.volumePercent = Math.max(0, Math.min(100, normalized.audio.volumePercent))
    latestAudioStatus = { ...normalized.audio }
  } else if (latestAudioStatus) {
    normalized.audio = { ...latestAudioStatus }
  }

  if (normalized.vision) {
    updateCameraRuntimeFromReading(normalized.vision)
    latestVisionStatus = getCameraRuntime()
  } else if (latestVisionStatus) {
    normalized.vision = { ...latestVisionStatus }
  }

  if (
    normalized.vision?.inference &&
    normalized.vision.inference.catDetected &&
    normalized.vision.inference.probability >= 0.5 &&
    normalized.catPresent === false
  ) {
    normalized.catPresent = true
  }

  const capacity = Math.max(0, activeSettings.waterBowlLevelTargetMl)
  const hasValidIntake =
    typeof normalized.waterIntakeMl === 'number' && Number.isFinite(normalized.waterIntakeMl) && normalized.waterIntakeMl >= 0

  if (typeof normalized.waterLevelPercent === 'number' && Number.isFinite(normalized.waterLevelPercent)) {
    const clamped = Math.min(100, Math.max(0, normalized.waterLevelPercent))
    normalized.waterLevelPercent = clamped
    if (!hasValidIntake || normalized.waterIntakeMl > capacity) {
      const remainingMl = (capacity * clamped) / 100
      normalized.waterIntakeMl = capacity > 0 ? Math.max(0, capacity - remainingMl) : 0
    }
  } else if (hasValidIntake && capacity > 0 && normalized.waterIntakeMl <= capacity) {
    const remaining = capacity - normalized.waterIntakeMl
    normalized.waterLevelPercent = Math.max(0, Math.min(100, (remaining / capacity) * 100))
  }

  if (typeof normalized.ambientLightPercent === 'number') {
    normalized.ambientLightPercent = Math.max(0, Math.min(100, normalized.ambientLightPercent))
  }

  const catThreshold = getCatPresenceThresholdKg()

  if (typeof normalized.catPresent !== 'boolean') {
    normalized.catPresent = normalized.catWeightKg >= catThreshold
  }

  if (typeof normalized.waterLevelPercent === 'number') {
    const waterPercent = Math.round(normalized.waterLevelPercent)
    if (normalized.waterLevelPercent < 10) {
      pushAlert({ key: 'waterLevelCritical', variables: { percent: waterPercent }, severity: 'critical' })
    } else if (normalized.waterLevelPercent < 25) {
      pushAlert({ key: 'waterLevelLow', variables: { percent: waterPercent }, severity: 'warning' })
    }
  }

  if (typeof normalized.ambientLightPercent === 'number' && normalized.catPresent) {
    const brightnessPercent = Math.round(normalized.ambientLightPercent)
    if (normalized.ambientLightPercent < 15) {
      pushAlert({ key: 'brightnessLow', severity: 'info' })
    } else if (normalized.ambientLightPercent > 90) {
      pushAlert({ key: 'brightnessHigh', variables: { percent: brightnessPercent }, severity: 'warning' })
    }
  }

  const nowInside = normalized.catPresent ?? normalized.catWeightKg >= catThreshold
  const wasInside = previousSnapshot
    ? previousSnapshot.reading.catPresent ?? previousSnapshot.reading.catWeightKg >= catThreshold
    : null
  if (wasInside === true && nowInside === false) {
    pushAlert({ key: 'catLeft', severity: 'info' })
  }

  if (nowInside === false && normalized.lastFeedingMinutesAgo > 360) {
    pushAlert({ key: 'catAwayTooLong', severity: 'warning' })
  }

  evaluateAlertRules(normalized)

  const snapshot = buildSnapshot(normalized, activeSettings)
  const enrichedSnapshot = snapshot.catId ? snapshot : { ...snapshot, catId }
  await applySnapshot(catId, enrichedSnapshot)
  if (catId === activeCatId) {
    latestSnapshot = enrichedSnapshot
  }
  console.log('[snapshot] stored', enrichedSnapshot.reading.timestamp, 'for cat', catId)
  return enrichedSnapshot
}

serialBridge = maybeStartSerialBridge((reading) => {
  console.log('[serial] received reading from Arduino')
  void handleIncomingReading(activeCatId, reading)
})

if (serialBridge) {
  pushSettingsToHardware(currentSettings)
  if (currentCalibration) {
    pushCalibrationToHardware(currentCalibration)
  }
}

app.post('/api/auth/login', loginLimiter, async (req, res) => {
  const username = typeof req.body?.username === 'string' ? req.body.username : ''
  const password = typeof req.body?.password === 'string' ? req.body.password : ''

  if (!username || !password) {
    res.status(400).json({ ok: false, message: 'missing-credentials' })
    return
  }

  // ðŸ”’ å®‰å…¨æ”¹é€²ï¼šç¾åœ¨ä½¿ç”¨ bcrypt ç•°æ­¥é©—è­‰å¯†ç¢¼
  const user = await authenticateUser(username, password)
  if (!user) {
    res.status(401).json({ ok: false, message: 'invalid-credentials' })
    return
  }

  const token = issueSession(user)
  res.json({
    ok: true,
    data: {
      token,
      user: getPublicUser(user),
    },
  })
})

app.post('/api/auth/logout', (req, res) => {
  invalidateSession(req.authToken)
  res.json({ ok: true })
})

app.get('/api/auth/me', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  res.json({ ok: true, data: { user: getPublicUser(req.authUser) } })
})

app.get('/health', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  const chatMetrics = getChatMetrics()
  const isDeveloper = req.authUser?.role === 'developer'
  const base = {
    status: 'healthy',
    lastSnapshotAt: latestSnapshot?.reading.timestamp ?? null,
    historyCount: loadHistory(HISTORY_LIMIT, activeCatId).length,
    llmTimeoutMs: aiConfig.request.overallMs,
    chat: {
      provider: chatMetrics.provider,
      source: isDeveloper ? chatMetrics.source ?? null : null,
      durationMs: chatMetrics.durationMs,
      updatedAt: chatMetrics.updatedAt,
      error: isDeveloper ? chatMetrics.error ?? null : null,
    },
    activeCatId,
    cats: listCats(),
  }

  const data = isDeveloper
    ? {
        ...base,
        toolEvents: getRecentToolEvents(5),
        pinnedToolEvents: getPinnedToolEvents(),
        alertRules: alertRulesCache,
        notifications: {
          fixes: listNotificationFixes(5),
        },
      }
    : {
        ...base,
        toolEvents: [],
        pinnedToolEvents: [],
        alertRules: [],
        notifications: {
          fixes: [],
        },
      }

  res.json({ ok: true, data })
})

app.get('/api/tool-events/pinned', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  res.json({ ok: true, data: getPinnedToolEvents() })
})

app.post('/api/tool-events/pinned', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const normalized = normalizeToolEventPayload(req.body)
  if (!normalized) {
    res.status(400).json({ ok: false, message: 'invalid-tool-event' })
    return
  }

  if (PINNED_TOOL_EVENTS.has(normalized.timestamp)) {
    res.json({ ok: true, data: getPinnedToolEvents() })
    return
  }

  const pinnedAt = new Date().toISOString()
  const entry = { ...normalized, pinnedAt }
  PINNED_TOOL_EVENTS.set(normalized.timestamp, entry)
  savePinnedToolEvent({ ...normalized, pinnedAt })
  enforcePinnedLimit()

  res.json({ ok: true, data: getPinnedToolEvents() })
})

app.delete('/api/tool-events/pinned/:timestamp', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const { timestamp } = req.params
  if (!timestamp) {
    res.status(400).json({ ok: false, message: 'missing-timestamp' })
    return
  }
  if (!PINNED_TOOL_EVENTS.has(timestamp)) {
    res.status(404).json({ ok: false, message: 'pinned-event-not-found' })
    return
  }
  PINNED_TOOL_EVENTS.delete(timestamp)
  removePinnedToolEvent(timestamp)
  res.json({ ok: true, data: getPinnedToolEvents() })
})

app.get('/api/alert-rules', (_req, res) => {
  res.json({ ok: true, data: alertRulesCache })
})

app.post('/api/alert-rules', (req, res) => {
  const validation = validateAlertRule(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const { metric, comparison, threshold, severity, message } = validation.value

  // Apply additional checks for metric using existing SET
  if (!ALERT_RULE_METRICS.has(metric as AlertRule['metric'])) {
    res.status(400).json({ ok: false, message: 'invalid-metric' })
    return
  }

  const payload = {
    metric: metric as AlertRule['metric'],
    comparison: comparison as AlertRule['comparison'],
    threshold,
    severity: severity as AlertRule['severity'],
    message,
    enabled: true,
  }

  const rule = createAlertRule(payload)
  refreshAlertRules()
  res.status(201).json({ ok: true, data: rule })
})

app.patch('/api/alert-rules/:id', (req, res) => {
  const id = Number(req.params.id)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-id' })
    return
  }

  const validation = validateAlertRule(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const { comparison, threshold, severity, message } = validation.value
  const enabled = typeof req.body.enabled === 'boolean' ? req.body.enabled : true

  const payload = {
    comparison: comparison as AlertRule['comparison'],
    threshold,
    severity: severity as AlertRule['severity'],
    message,
    enabled,
  }

  updateAlertRule({ id, ...payload })
  refreshAlertRules()
  const updated = alertRulesCache.find((rule) => rule.id === id)
  if (!updated) {
    res.status(404).json({ ok: false, message: 'alert-rule-not-found' })
    return
  }
  res.json({ ok: true, data: updated })
})

app.delete('/api/alert-rules/:id', (req, res) => {
  const id = Number(req.params.id)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-id' })
    return
  }
  removeAlertRule(id)
  refreshAlertRules()
  res.json({ ok: true, data: alertRulesCache })
})

app.get('/api/memories/keywords', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const limitParam = req.query.limit
  const limit = typeof limitParam === 'string' ? Number(limitParam) : 20
  const safeLimit = Number.isFinite(limit) && limit > 0 ? Math.min(Math.floor(limit), 50) : 20
  res.json({ ok: true, data: getMemoryKeywordStats(safeLimit) })
})

app.get('/api/chat/favorites', (_req, res) => {
  res.json({ ok: true, data: listChatFavorites() })
})

app.post('/api/chat/favorites', (req, res) => {
  const validation = validateChatFavorite(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const { role, content } = validation.value
  const { messageId, metadata } = req.body ?? {}

  // Additional validation for messageId
  if (messageId !== undefined && typeof messageId !== 'string') {
    res.status(400).json({ ok: false, message: 'invalid-message-id' })
    return
  }

  // Additional validation for metadata
  if (metadata && typeof metadata !== 'object') {
    res.status(400).json({ ok: false, message: 'invalid-metadata' })
    return
  }

  const payload: {
    messageId?: string | null
    role: ChatFavorite['role']
    content: string
    metadata?: Record<string, unknown>
  } = {
    role: role as ChatFavorite['role'],
    content,
  }

  if (typeof messageId === 'string' && messageId.length > 0) {
    payload.messageId = messageId
  }
  if (metadata && typeof metadata === 'object') {
    payload.metadata = metadata as Record<string, unknown>
  }

  const favorite = saveChatFavorite(payload)
  res.status(201).json({ ok: true, data: favorite })
})

app.delete('/api/chat/favorites/:id', (req, res) => {
  const idParam = req.params.id
  const messageId = typeof req.query.messageId === 'string' ? req.query.messageId : undefined
  const numericId = Number(idParam)
  if (!Number.isFinite(numericId) && !messageId) {
    res.status(400).json({ ok: false, message: 'invalid-id' })
    return
  }
  const payload: { id?: number; messageId?: string | null } = {}
  if (Number.isFinite(numericId)) {
    payload.id = numericId
  }
  if (messageId && messageId.length > 0) {
    payload.messageId = messageId
  }
  deleteChatFavorite(payload)
  res.json({ ok: true })
})

app.get('/api/reports/professional', (req, res) => {
  const reportCatId = typeof req.query.catId === 'string' && req.query.catId.trim().length > 0 ? req.query.catId.trim() : activeCatId
  const snapshot = loadLatestSnapshot(reportCatId)
  const history = loadHistory(Math.max(HISTORY_LIMIT, 96), reportCatId)
  const alerts = loadAutomationAlerts(10)
  const report = buildProfessionalCareReport({
    snapshot,
    history,
    alerts,
    settings: currentSettings,
    language: getPreferredLanguage(),
  })
  res.json({ ok: true, data: report })
})

app.get('/api/analytics/insights', (req, res) => {
  const insightsCatId = typeof req.query.catId === 'string' && req.query.catId.trim().length > 0 ? req.query.catId.trim() : activeCatId
  const snapshot = loadLatestSnapshot(insightsCatId)
  const history = loadHistory(Math.max(HISTORY_LIMIT, 96), insightsCatId)
  const insights = deriveCareInsights(getPreferredLanguage(), snapshot, history, currentSettings)
  res.json({
    ok: true,
    data: {
      generatedAt: new Date().toISOString(),
      sampleCount: history.length,
      insights,
    },
  })
})

app.get('/api/analytics/forecast', (req, res) => {
  const forecastCatId = typeof req.query.catId === 'string' && req.query.catId.trim().length > 0 ? req.query.catId.trim() : activeCatId
  const history = loadHistory(Math.max(HISTORY_LIMIT, 120), forecastCatId)
  const forecast = deriveBehaviorForecast(getPreferredLanguage(), history)
  res.json({ ok: true, data: forecast })
})

app.get('/api/behavior/profile', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  const profileCatId =
    typeof req.query.catId === 'string' && req.query.catId.trim().length > 0 ? req.query.catId.trim() : activeCatId
  try {
    const profile = ensureBehaviorProfile(profileCatId)
    res.json({ ok: true, data: profile })
  } catch (error) {
    console.error('[behavior] Failed to load behavior profile', error)
    res.status(500).json({ ok: false, message: 'behavior-profile-unavailable' })
  }
})

app.post('/api/behavior/profile/refresh', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const profileCatId =
    typeof req.body?.catId === 'string' && req.body.catId.trim().length > 0 ? req.body.catId.trim() : activeCatId
  try {
    const profile = refreshBehaviorProfile(profileCatId)
    res.json({ ok: true, data: profile })
  } catch (error) {
    console.error('[behavior] Failed to refresh behavior profile', error)
    res.status(500).json({ ok: false, message: 'behavior-profile-refresh-failed' })
  }
})

app.get('/api/knowledge/articles', (req, res) => {
  const queryRaw = typeof req.query.q === 'string' ? req.query.q : ''

  // Validate and sanitize query parameter
  const queryValidation = validateQueryString(queryRaw)
  if (!queryValidation.ok && queryRaw.length > 0) {
    res.status(400).json({ ok: false, message: queryValidation.message })
    return
  }
  const query = queryValidation.ok ? queryValidation.value : ''

  const tagsRaw = typeof req.query.tags === 'string' ? req.query.tags : ''
  const parsedTags = tagsRaw
    .split(/[,;]/)
    .map((tag) => sanitizeString(tag))
    .filter((tag) => tag.length > 0 && tag.length <= VALIDATION_LIMITS.MAX_SHORT_TEXT_LENGTH)

  const limitParam = typeof req.query.limit === 'string' ? Number.parseInt(req.query.limit, 10) : 5
  const limit = Number.isFinite(limitParam) && limitParam > 0 ? Math.min(limitParam, 10) : 5

  const articles =
    query.trim().length > 0 || parsedTags.length > 0
      ? retrieveKnowledgeArticles(getPreferredLanguage(), query, limit, parsedTags)
      : listKnowledgeArticles(getPreferredLanguage()).slice(0, limit)

  res.json({ ok: true, data: articles })
})

app.get('/api/tasks', (req, res) => {
  const limitParam = typeof req.query.limit === 'string' ? Number.parseInt(req.query.limit, 10) : 50
  const limit = Number.isFinite(limitParam) && limitParam > 0 ? Math.min(limitParam, 100) : 50
  const tasks = listCareTasks(limit)
  res.json({ ok: true, data: tasks })
})

app.post('/api/tasks', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }

  const validation = validateTask(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const { title, description, category, dueDate } = validation.value
  const safeDescription = description ?? ''
  const { metadata } = req.body ?? {}

  // Additional validation for metadata
  if (metadata && typeof metadata !== 'object') {
    res.status(400).json({ ok: false, message: 'invalid-metadata' })
    return
  }

  const taskPayload: Parameters<typeof createCareTask>[0] = {
    title,
    description: safeDescription,
    category: category as CareInsightCategory | 'general',
    source: 'user',
  }

  if (dueDate && dueDate.length > 0) {
    taskPayload.dueAt = dueDate
  }
  if (metadata && typeof metadata === 'object') {
    taskPayload.metadata = metadata as Record<string, unknown>
  }

  const task = createCareTask(taskPayload)
  res.status(201).json({ ok: true, data: task })
})

app.post('/api/tasks/suggest', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  const snapshot = loadLatestSnapshot(activeCatId)
  const history = loadHistory(Math.max(HISTORY_LIMIT, 96), activeCatId)
  const suggestions = suggestCareTasks(getPreferredLanguage(), snapshot, history)
  const existingTasks = listCareTasks(100)
  const pendingKeys = new Set(
    existingTasks
      .filter((task) => task.status === 'pending')
      .map((task) => `${task.category}|${task.title}`),
  )
  const created: CareTask[] = []
  for (const suggestion of suggestions) {
    const key = `${suggestion.category}|${suggestion.title}`
    if (pendingKeys.has(key)) continue
    pendingKeys.add(key)
    const suggestionPayload: Parameters<typeof createCareTask>[0] = {
      title: suggestion.title,
      description: suggestion.description,
      category: suggestion.category,
      source: 'ai',
    }
    if (suggestion.dueAt) {
      suggestionPayload.dueAt = suggestion.dueAt
    }
    const metadata: Record<string, unknown> = suggestion.metadata ? { ...suggestion.metadata } : {}
    if (suggestion.urgency) {
      metadata.urgency = suggestion.urgency
    }
    if (Object.keys(metadata).length > 0) {
      suggestionPayload.metadata = metadata
    }
    const task = createCareTask(suggestionPayload)
    created.push(task)
  }
  res.json({
    ok: true,
    data: {
      generatedAt: new Date().toISOString(),
      created,
      suggestions,
    },
  })
})

app.patch('/api/tasks/:id', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-task-id' })
    return
  }
  const { status } = req.body ?? {}
  if (typeof status !== 'string' || !CARE_TASK_STATUS_VALUES.has(status as CareTaskStatus)) {
    res.status(400).json({ ok: false, message: 'invalid-task-status' })
    return
  }
  const updated = updateCareTaskStatus(id, status as CareTaskStatus)
  if (!updated) {
    res.status(404).json({ ok: false, message: 'task-not-found' })
    return
  }
  res.json({ ok: true, data: updated })
})

app.delete('/api/tasks/:id', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-task-id' })
    return
  }
  removeCareTask(id)
  res.json({ ok: true })
})

app.get('/api/plugins', (req, res) => {
  if (!ensureDeveloperOrAdmin(req, res)) {
    return
  }
  res.json({ ok: true, data: listCarePlugins() })
})

app.post('/api/plugins', (req, res) => {
  if (!ensureDeveloperOrAdmin(req, res)) {
    return
  }

  const { capabilities, enabled, metadata, apiBaseUrl: apiBaseUrlRaw } = req.body ?? {}

  // Prepare validation payload with required apiBaseUrl (use placeholder if empty)
  const validationPayload = {
    ...req.body,
    apiBaseUrl: typeof apiBaseUrlRaw === 'string' && apiBaseUrlRaw.trim().length > 0
      ? apiBaseUrlRaw
      : 'http://placeholder.local', // Placeholder for validation
  }

  // Only validate if apiBaseUrl is provided and non-empty
  if (typeof apiBaseUrlRaw === 'string' && apiBaseUrlRaw.trim().length > 0) {
    const validation = validatePlugin(validationPayload)
    if (!validation.ok) {
      res.status(400).json({ ok: false, message: validation.message })
      return
    }
  } else {
    // Still validate name and description without apiBaseUrl
    if (typeof req.body?.name !== 'string' || sanitizeString(req.body.name).length === 0) {
      res.status(400).json({ ok: false, message: 'plugin-name-required' })
      return
    }
    if (req.body?.name && sanitizeString(req.body.name).length > VALIDATION_LIMITS.MAX_SHORT_TEXT_LENGTH) {
      res.status(400).json({ ok: false, message: 'plugin-name-too-long' })
      return
    }
    if (req.body?.description && sanitizeString(req.body.description).length > VALIDATION_LIMITS.MAX_CONTENT_LENGTH) {
      res.status(400).json({ ok: false, message: 'plugin-description-too-long' })
      return
    }
  }

  // Additional validation for other fields
  if (capabilities && !Array.isArray(capabilities)) {
    res.status(400).json({ ok: false, message: 'plugin-capabilities-invalid' })
    return
  }
  if (metadata && typeof metadata !== 'object') {
    res.status(400).json({ ok: false, message: 'plugin-metadata-invalid' })
    return
  }

  const normalizedCapabilities = Array.isArray(capabilities)
    ? capabilities.filter((value): value is string => typeof value === 'string' && value.trim().length > 0)
    : []

  const pluginPayload: Parameters<typeof upsertCarePlugin>[0] = {
    name: sanitizeString(req.body.name),
    enabled: typeof enabled === 'boolean' ? enabled : true,
  }

  if (normalizedCapabilities.length > 0) {
    pluginPayload.capabilities = normalizedCapabilities
  }
  if (typeof req.body.description === 'string') {
    const trimmedDescription = sanitizeString(req.body.description)
    if (trimmedDescription.length > 0) {
      pluginPayload.description = trimmedDescription
    }
  }
  if (typeof apiBaseUrlRaw === 'string') {
    const trimmedBase = apiBaseUrlRaw.trim()
    pluginPayload.apiBaseUrl = trimmedBase.length > 0 ? trimmedBase : null
  }
  if (metadata && typeof metadata === 'object') {
    pluginPayload.metadata = metadata as Record<string, unknown>
  }

  const plugin = upsertCarePlugin(pluginPayload)
  res.status(201).json({ ok: true, data: plugin })
})

app.patch('/api/plugins/:id', (req, res) => {
  if (!ensureDeveloperOrAdmin(req, res)) {
    return
  }
  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-plugin-id' })
    return
  }
  const { enabled } = req.body ?? {}
  if (typeof enabled !== 'boolean') {
    res.status(400).json({ ok: false, message: 'plugin-enabled-required' })
    return
  }
  const updated = updateCarePluginEnabled(id, enabled)
  if (!updated) {
    res.status(404).json({ ok: false, message: 'plugin-not-found' })
    return
  }
  res.json({ ok: true, data: updated })
})

app.delete('/api/plugins/:id', (req, res) => {
  if (!ensureDeveloperOrAdmin(req, res)) {
    return
  }
  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-plugin-id' })
    return
  }
  deleteCarePlugin(id)
  res.json({ ok: true })
})

app.get('/api/diagnostics/report', (_req, res) => {
  const report = buildDiagnosticReport()
  res.setHeader('Content-Type', 'text/plain; charset=utf-8')
  res.setHeader('Content-Disposition', 'attachment; filename="smart-cat-home-report.txt"')
  res.send(report)
})

app.post('/api/diagnostics/notifications/fix', (req, res) => {
  const { step, success, message } = req.body ?? {}
  if (!isNotificationFixStep(step) || typeof success !== 'boolean') {
    res.status(400).json({ ok: false, message: 'invalid-payload' })
    return
  }
  const normalizedMessage = typeof message === 'string' && message.trim().length > 0 ? message.trim() : undefined
  const log = recordNotificationFix(step, success, normalizedMessage)
  res.json({ ok: true, data: log })
})

app.get('/api/settings', (_req, res) => {
  res.json({ ok: true, data: currentSettings })
})

app.post('/api/settings', async (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }

  const incoming = req.body
  if (!isSmartHomeSettings(incoming)) {
    res.status(400).json({ ok: false, message: 'invalid-settings-payload' })
    return
  }

  const previous = { ...currentSettings }
  await applySettings(incoming)
  recordSettingsMemory(previous, currentSettings, 'api:updateSettings')
  res.json({ ok: true, data: currentSettings })
})

app.get('/api/audio/status', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  const snapshot = latestSnapshot ?? latestSnapshotsByCat.get(activeCatId) ?? null
  const status = snapshot?.reading.audio ?? latestAudioStatus ?? null
  res.json({ ok: true, data: status })
})

app.post('/api/audio/play', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  const rawPattern = typeof req.body?.pattern === 'string' ? req.body.pattern : 'call-cat'
  const pattern = rawPattern.trim().length > 0 ? rawPattern.trim() : 'call-cat'
  const repeatRaw =
    typeof req.body?.repeat === 'number'
      ? req.body.repeat
      : typeof req.body?.repeat === 'string'
        ? Number.parseInt(req.body.repeat, 10)
        : 1
  const repeat = Number.isFinite(repeatRaw) && repeatRaw > 0 ? Math.min(10, Math.max(1, repeatRaw)) : 1
  try {
    triggerAudioPattern(pattern, repeat)
    res.json({ ok: true, data: latestAudioStatus })
  } catch (error) {
    console.error('[audio] play command failed', error)
    res.status(500).json({ ok: false, message: safeErrorMessage(error) })
  }
})

app.post('/api/audio/stop', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  try {
    stopAudioPlayback()
    res.json({ ok: true, data: latestAudioStatus })
  } catch (error) {
    console.error('[audio] stop command failed', error)
    res.status(500).json({ ok: false, message: safeErrorMessage(error) })
  }
})

app.post('/api/audio/config', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  const body = req.body ?? {}
  const muted =
    typeof body.muted === 'boolean'
      ? body.muted
      : typeof body.muted === 'string'
        ? body.muted.toLowerCase() === 'true'
        : undefined
  const volumeRaw =
    typeof body.volumePercent === 'number'
      ? body.volumePercent
      : typeof body.volumePercent === 'string'
        ? Number.parseFloat(body.volumePercent)
        : typeof body.volume === 'number'
          ? body.volume
          : typeof body.volume === 'string'
            ? Number.parseFloat(body.volume)
            : undefined
  const pattern = typeof body.pattern === 'string' ? body.pattern : undefined
  const repeat =
    typeof body.repeat === 'number'
      ? body.repeat
      : typeof body.repeat === 'string'
        ? Number.parseInt(body.repeat, 10)
        : undefined

  if (typeof muted === 'undefined' && typeof volumeRaw === 'undefined' && typeof pattern === 'undefined') {
    res.status(400).json({ ok: false, message: 'audio-config-empty' })
    return
  }

  try {
    updateAudioConfiguration({
      muted,
      volumePercent: typeof volumeRaw === 'number' && Number.isFinite(volumeRaw) ? volumeRaw : undefined,
      pattern,
      repeat,
    })
    res.json({ ok: true, data: latestAudioStatus })
  } catch (error) {
    console.error('[audio] config update failed', error)
    res.status(500).json({ ok: false, message: safeErrorMessage(error) })
  }
})

app.get('/api/camera/status', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  res.json({ ok: true, data: getCameraRuntime() })
})

app.post('/api/camera/refresh', async (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }
  const status = await pollCameraStatus()
  if (status) {
    patchLatestVisionStatus(status)
    res.json({ ok: true, data: getCameraRuntime() })
    return
  }
  res.status(503).json({ ok: false, message: 'camera-offline', data: getCameraRuntime() })
})

app.get('/api/camera/snapshot', async (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  const snapshot = await fetchCameraSnapshotBuffer()
  if (!snapshot) {
    res.status(503).json({ ok: false, message: 'camera-snapshot-unavailable' })
    return
  }
  patchLatestVisionStatus(getCameraRuntime())
  res.setHeader('Content-Type', snapshot.contentType)
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate')
  res.send(snapshot.buffer)
})

app.post('/api/camera/events', (req, res) => {
  if (!ensureHardwareAuthorized(req, res)) {
    return
  }
  const body = req.body ?? {}
  if (typeof body.catDetected !== 'boolean') {
    res.status(400).json({ ok: false, message: 'catDetected-required' })
    return
  }

  const eventPayload = {
    deviceId: typeof body.deviceId === 'string' ? body.deviceId : undefined,
    catDetected: body.catDetected,
    probability:
      typeof body.probability === 'number'
        ? body.probability
        : typeof body.probability === 'string'
          ? Number.parseFloat(body.probability)
          : undefined,
    mean:
      typeof body.mean === 'number'
        ? body.mean
        : typeof body.mean === 'string'
          ? Number.parseFloat(body.mean)
          : undefined,
    stdDev:
      typeof body.stdDev === 'number'
        ? body.stdDev
        : typeof body.stdDev === 'string'
          ? Number.parseFloat(body.stdDev)
          : undefined,
    edgeDensity:
      typeof body.edgeDensity === 'number'
        ? body.edgeDensity
        : typeof body.edgeDensity === 'string'
          ? Number.parseFloat(body.edgeDensity)
          : undefined,
    timestampMs:
      typeof body.timestampMs === 'number'
        ? body.timestampMs
        : typeof body.timestamp === 'number'
          ? body.timestamp
          : undefined,
    timestampIso:
      typeof body.timestampIso === 'string'
        ? body.timestampIso
        : typeof body.timestamp === 'string'
          ? body.timestamp
          : undefined,
    modelId: typeof body.modelId === 'string' ? body.modelId : undefined,
  }

  const runtime = ingestCameraEvent(eventPayload)
  patchLatestVisionStatus(runtime)
  res.json({ ok: true, data: getCameraRuntime() })
})

app.get('/api/snapshot/latest', (req, res) => {
  const queryCatId = typeof req.query.catId === 'string' && req.query.catId.trim().length > 0 ? req.query.catId.trim() : activeCatId
  const snapshot = latestSnapshotsByCat.get(queryCatId) ?? null
  if (!snapshot) {
    res.status(404).json({ ok: false, message: 'snapshot-not-found' })
    return
  }
  const enriched: SmartHomeSnapshot = {
    ...snapshot,
    reading: {
      ...snapshot.reading,
      ...(snapshot.reading.audio ? {} : latestAudioStatus ? { audio: { ...latestAudioStatus } } : {}),
      ...(snapshot.reading.vision ? {} : latestVisionStatus ? { vision: { ...latestVisionStatus } } : {}),
    },
  }
  res.json({ ok: true, data: enriched })
})

app.post('/api/snapshots', async (req, res) => {
  if (!ensureHardwareAuthorized(req, res)) {
    return
  }

  try {
    const { reading, settings, catId: rawCatId, catProfile } = req.body ?? {}

    if (!isSmartHomeReading(reading)) {
      res.status(400).json({ ok: false, message: 'invalid-reading' })
      return
    }

    const requestedCatId = typeof rawCatId === 'string' && rawCatId.trim().length > 0 ? rawCatId.trim() : activeCatId
    if (!catRegistry.has(requestedCatId)) {
      const fallbackName =
        (catProfile && typeof catProfile.name === 'string' && catProfile.name.trim().length > 0
          ? catProfile.name.trim()
          : `Cat ${requestedCatId}`)
      const created = upsertCat({
        id: requestedCatId,
        name: fallbackName,
        avatarUrl: typeof catProfile?.avatarUrl === 'string' ? catProfile.avatarUrl : null,
        breed: typeof catProfile?.breed === 'string' ? catProfile.breed : null,
        birthdate: typeof catProfile?.birthdate === 'string' ? catProfile.birthdate : null,
        weightKg: typeof catProfile?.weightKg === 'number' ? catProfile.weightKg : null,
        notes: typeof catProfile?.notes === 'string' ? catProfile.notes : null,
        tags: Array.isArray(catProfile?.tags) ? catProfile.tags : null,
      })
      catRegistry.set(created.id, created)
    }

    if (!catRegistry.has(activeCatId)) {
      activeCatId = requestedCatId
    }

    let activeSettings = currentSettings
    if (settings && isSmartHomeSettings(settings)) {
      activeSettings = settings
      await applySettings(settings)
    }

    const normalizedReading: SmartHomeReading = {
      ...reading,
      timestamp: reading.timestamp,
    }

    const snapshot = await handleIncomingReading(requestedCatId, normalizedReading, activeSettings)
    res.json({ ok: true, data: snapshot })
  } catch (error) {
    console.error('[snapshots] Failed to process snapshot:', error)
    const errorMessage = error instanceof Error ? error.message : 'Failed to process snapshot data'
    res.status(500).json({
      ok: false,
      message: errorMessage,
      error: 'SNAPSHOT_PROCESSING_ERROR',
    })
  }
})

app.get('/api/history', (req, res) => {
  const queryCatId = typeof req.query.catId === 'string' && req.query.catId.trim().length > 0 ? req.query.catId.trim() : activeCatId
  const history = loadHistory(HISTORY_LIMIT, queryCatId)
  res.json({ ok: true, data: history })
})

app.get('/api/cats', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  const cats = listCats()
  cats.forEach((cat) => catRegistry.set(cat.id, cat))
  res.json({ ok: true, data: { cats, activeCatId } })
})

app.post('/api/cats', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }

  const id = typeof req.body?.id === 'string' && req.body.id.trim().length > 0 ? req.body.id.trim() : undefined
  const validation = validateCatPayload(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const cat = upsertCat({ id, ...validation.value })
  catRegistry.set(cat.id, cat)

  if (req.body?.setActive === true) {
    activeCatId = cat.id
    latestSnapshot = latestSnapshotsByCat.get(cat.id) ?? null
  }

  res.status(201).json({ ok: true, data: cat })
})

app.patch('/api/cats/:id', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }

  const catId = req.params.id.trim()
  const validation = validateCatPayload(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const existing = getCat(catId)
  if (!existing) {
    res.status(404).json({ ok: false, message: 'cat-not-found' })
    return
  }

  const updated = upsertCat({ id: catId, ...validation.value })
  catRegistry.set(updated.id, updated)
  if (updated.id === activeCatId) {
    latestSnapshot = latestSnapshotsByCat.get(updated.id) ?? latestSnapshot
  }
  res.json({ ok: true, data: updated })
})

app.post('/api/cats/:id/select', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }

  const requested = req.params.id.trim()
  const cat = catRegistry.get(requested) ?? getCat(requested)
  if (!cat) {
    res.status(404).json({ ok: false, message: 'cat-not-found' })
    return
  }
  catRegistry.set(cat.id, cat)
  activeCatId = cat.id
  const snapshot = latestSnapshotsByCat.get(cat.id) ?? loadLatestSnapshot(cat.id)
  if (snapshot) {
    const normalized = snapshot.catId ? snapshot : { ...snapshot, catId: cat.id }
    latestSnapshotsByCat.set(cat.id, normalized)
    latestSnapshot = normalized
  } else {
    latestSnapshot = null
  }

  try {
    ensureBehaviorProfile(activeCatId)
  } catch (error) {
    console.warn('[behavior] Failed to ensure profile after cat select', error)
  }

  res.json({ ok: true, data: { activeCatId, snapshot: latestSnapshot } })
})

app.delete('/api/cats/:id', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }

  const catId = req.params.id.trim()
  if (catId === DEFAULT_CAT_ID) {
    res.status(400).json({ ok: false, message: 'cannot-delete-default-cat' })
    return
  }

  const existing = getCat(catId)
  if (!existing) {
    res.status(404).json({ ok: false, message: 'cat-not-found' })
    return
  }

  const removed = removeCat(catId)
  if (!removed) {
    res.status(500).json({ ok: false, message: 'cat-delete-failed' })
    return
  }

  catRegistry.delete(catId)
  latestSnapshotsByCat.delete(catId)
  const pending = pendingBehaviorRefreshTimers.get(catId)
  if (pending) {
    clearTimeout(pending)
    pendingBehaviorRefreshTimers.delete(catId)
  }
  if (activeCatId === catId) {
    activeCatId = catRegistry.has(DEFAULT_CAT_ID)
      ? DEFAULT_CAT_ID
      : catRegistry.values().next()?.value?.id ?? DEFAULT_CAT_ID
    latestSnapshot = latestSnapshotsByCat.get(activeCatId) ?? null
  }

  res.json({ ok: true })
})

app.get('/api/alerts/recent', (_req, res) => {
  res.json({ ok: true, data: recentAlerts })
})

app.get('/api/calibration', (_req, res) => {
  res.json({ ok: true, data: currentCalibration ?? {} })
})

app.post('/api/calibration', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }

  const normalized = normalizeCalibrationPayload(req.body)
  if (!normalized) {
    res.status(400).json({ ok: false, message: 'invalid-calibration-payload' })
    return
  }

  const previous = currentCalibration ? { ...currentCalibration } : null
  currentCalibration = normalized.profile
  if (normalized.changed) {
    saveCalibration(normalized.profile)
    recordCalibrationMemory(previous, normalized.profile, 'api:updateCalibration')

    // Generate summary before saving to history
    const summary = summarizeCalibrationAdjustment(getPreferredLanguage(), previous, normalized.profile)

    // Save to calibration history
    try {
      const changedFields = Object.keys(normalized.profile).filter((key) => {
        const prevValue = previous?.[key as keyof CalibrationProfile]
        const newValue = normalized.profile[key as keyof CalibrationProfile]
        return prevValue !== newValue
      })

      saveCalibrationHistory({
        calibration: normalized.profile,
        changeSummary: summary ?? null,
        changedFields: changedFields.length > 0 ? changedFields : null,
        changedBy: 'api',
        previousValues: previous ? (previous as Record<string, unknown>) : null,
        newValues: normalized.profile as Record<string, unknown>,
      })
    } catch (error) {
      console.error('[calibration] Failed to save calibration history', error)
    }

    res.json({
      ok: true,
      data: {
        profile: currentCalibration,
        summary: summary ?? null,
      },
    })
  } else {
    res.json({
      ok: true,
      data: {
        profile: currentCalibration,
        summary: null,
      },
    })
  }
})

app.get('/api/calibration/history', (_req, res) => {
  try {
    const limit = Number.parseInt(_req.query.limit as string, 10) || 50
    const offset = Number.parseInt(_req.query.offset as string, 10) || 0
    const total = countCalibrationHistory()
    const history = getCalibrationHistory(limit, offset)

    res.json({
      ok: true,
      data: {
        items: history,
        total,
        limit,
        offset,
      },
    })
  } catch (error) {
    console.error('[calibration] Failed to get calibration history', error)
    res.status(500).json({ ok: false, message: 'failed-to-get-history' })
  }
})

app.post('/api/calibration/rollback/:id', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }

  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-history-id' })
    return
  }

  try {
    const historyRecord = getCalibrationHistoryById(id)
    if (!historyRecord) {
      res.status(404).json({ ok: false, message: 'history-not-found' })
      return
    }

    const calibrationToRestore = JSON.parse(historyRecord.calibrationJson) as CalibrationProfile
    const previous = currentCalibration ? { ...currentCalibration } : null

    currentCalibration = calibrationToRestore
    saveCalibration(calibrationToRestore)
    recordCalibrationMemory(previous, calibrationToRestore, 'api:rollback')

    // Save rollback action to history
    saveCalibrationHistory({
      calibration: calibrationToRestore,
      changeSummary: `Rolled back to version #${id}`,
      changedBy: 'rollback',
      previousValues: previous ? (previous as Record<string, unknown>) : null,
      newValues: calibrationToRestore as Record<string, unknown>,
    })

    const summary = summarizeCalibrationAdjustment(getPreferredLanguage(), previous, calibrationToRestore)
    res.json({
      ok: true,
      data: {
        profile: currentCalibration,
        summary: summary ?? null,
      },
    })
  } catch (error) {
    console.error('[calibration] Failed to rollback calibration', error)
    res.status(500).json({ ok: false, message: 'rollback-failed' })
  }
})

app.post('/api/hardware/commands', (req, res) => {
  if (!ensureAdminAuthorized(req, res)) {
    return
  }

  const type = typeof req.body?.type === 'string' ? req.body.type.trim() : ''
  if (!type) {
    res.status(400).json({ ok: false, message: 'command-type-required' })
    return
  }

  const allowedTypes = new Set(['updateSettings', 'updateCalibration', 'playAudioPattern', 'stopAudio', 'setAudioState'])
  if (!allowedTypes.has(type)) {
    res.status(400).json({ ok: false, message: 'unsupported-command-type' })
    return
  }

  const payload = req.body?.payload ?? null
  try {
    const command = enqueueHardwareCommand(type, payload)
    res.status(201).json({ ok: true, data: serializeHardwareCommand(command) })
  } catch (error) {
    console.error('[hardware] Failed to enqueue hardware command', error)
    res.status(500).json({ ok: false, message: 'command-enqueue-failed' })
  }
})

app.get('/api/hardware/commands/pending', (req, res) => {
  if (!ensureHardwareAuthorized(req, res)) {
    return
  }

  const command = claimNextHardwareCommand()
  if (!command) {
    res.status(204).send()
    return
  }

  res.json({ ok: true, data: serializeHardwareCommand(command) })
})

app.post('/api/hardware/commands/:id/ack', (req, res) => {
  if (!ensureHardwareAuthorized(req, res)) {
    return
  }

  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-command-id' })
    return
  }

  const command = getHardwareCommandById(id)
  if (!command) {
    res.status(404).json({ ok: false, message: 'command-not-found' })
    return
  }

  const status = req.body?.status === 'success' ? 'completed' : req.body?.status === 'error' ? 'failed' : null
  if (!status) {
    res.status(400).json({ ok: false, message: 'invalid-status' })
    return
  }

  const message = typeof req.body?.message === 'string' ? req.body.message : undefined

  const updated = completeHardwareCommand(id, status, message)
  if (!updated) {
    res.status(409).json({ ok: false, message: 'command-status-conflict' })
    return
  }

  res.json({ ok: true, data: serializeHardwareCommand(updated) })
})

app.post('/api/preferences/language', (req, res) => {
  const language = req.body?.language
  if (language === 'zh' || language === 'en') {
    setPersistedLanguage(language)
    res.json({ ok: true, data: { language } })
    return
  }

  res.status(400).json({ ok: false, message: 'unsupported-language' })
})

app.get('/api/preferences/dashboard', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  try {
    const layout = loadDashboardLayoutPreference(req.authUser.username)
    res.json({ ok: true, data: layout })
  } catch (error) {
    console.error('[preferences] Failed to load dashboard layout', error)
    res.status(500).json({ ok: false, message: 'dashboard-preferences-load-failed' })
  }
})

app.post('/api/preferences/dashboard', (req, res) => {
  if (!requireAuthenticated(req, res)) {
    return
  }
  const hiddenPanels = Array.isArray(req.body?.hiddenPanels) ? req.body.hiddenPanels : undefined
  const panelOrder = Array.isArray(req.body?.panelOrder) ? req.body.panelOrder : undefined
  try {
    const layout = saveDashboardLayoutPreference(req.authUser.username, {
      hiddenPanels,
      panelOrder,
    })
    res.json({ ok: true, data: layout })
  } catch (error) {
    console.error('[preferences] Failed to save dashboard layout', error)
    res.status(500).json({ ok: false, message: 'dashboard-preferences-save-failed' })
  }
})

app.post('/api/push-subscriptions', (req, res) => {
  const subscription = req.body?.subscription as StoredPushSubscription | undefined
  const language = req.body?.language

  if (!subscription || typeof subscription.endpoint !== 'string') {
    res.status(400).json({ ok: false, message: 'invalid-subscription' })
    return
  }

  const lang: LanguageCode = language === 'en' ? 'en' : 'zh'
  try {
    savePushSubscription(subscription, lang)
    res.json({ ok: true })
  } catch (error) {
    console.error('[push] Failed to persist subscription', error)
    res.status(500).json({ ok: false, message: 'push-subscription-save-failed' })
  }
})

app.get('/api/memories', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const typeParam = typeof req.query?.type === 'string' ? req.query.type : undefined
  if (typeParam && !isMemoryType(typeParam)) {
    res.status(400).json({ ok: false, message: 'unsupported-memory-type' })
    return
  }
  const limitParam = Number.parseInt(typeof req.query?.limit === 'string' ? req.query.limit : '', 10)
  const limit = Number.isFinite(limitParam) ? Math.max(1, Math.min(100, limitParam)) : 20
  const memories = listMemories(limit, typeParam)
    .filter((entry) => isMemoryType(entry.type))
    .map((entry) => ({
      id: entry.id,
      type: entry.type as MemoryType,
      content: entry.content,
      source: entry.source,
      createdAt: entry.createdAt,
    }))
  res.json({ ok: true, data: memories })
})

app.post('/api/memories', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }

  const validation = validateMemory(req.body)
  if (!validation.ok) {
    res.status(400).json({ ok: false, message: validation.message })
    return
  }

  const { type, content, source } = validation.value
  const memory = addMemory({
    type,
    content,
    source,
  })
  res.status(201).json({ ok: true, data: memory })
})

app.patch('/api/memories/:id', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-memory-id' })
    return
  }

  const content = typeof req.body?.content === 'string' ? sanitizeString(req.body.content) : ''
  if (content.length === 0) {
    res.status(400).json({ ok: false, message: 'invalid-memory-update-empty-content' })
    return
  }

  if (content.length > VALIDATION_LIMITS.MAX_CONTENT_LENGTH) {
    res.status(400).json({ ok: false, message: 'invalid-memory-update-content-too-long' })
    return
  }

  updateMemory(id, content)
  res.json({ ok: true })
})

app.delete('/api/memories/:id', (req, res) => {
  if (!requireDeveloper(req, res)) {
    return
  }
  const id = Number.parseInt(req.params.id, 10)
  if (!Number.isFinite(id)) {
    res.status(400).json({ ok: false, message: 'invalid-memory-id' })
    return
  }
  removeMemory(id)
  res.json({ ok: true })
})

// ==================== çŸ¥è­˜æå– API ====================

app.post('/api/knowledge/extract', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const { messages, catId } = req.body

    if (!Array.isArray(messages)) {
      return res.status(400).json({ success: false, error: 'Messages must be an array' })
    }

    const resolvedCatId = typeof catId === 'string' ? catId : 'default'

    // ä½¿ç”¨ AI æå–çŸ¥è­˜
    const result = await knowledgeExtractor.extractKnowledgeWithAI(
      messages,
      resolvedCatId,
      async (prompt) => {
        const chatResult = await generateChatContent({
          question: prompt,
          historyMessages: [],
          knowledgePrompt: '',
          personality: 'PhiLia093',
          modelConfig: { ...aiConfig.standard },
          provider: 'local',
          isDeveloper: false,
          enableSearch: false,
          language: 'zh'
        })
        return chatResult.text
      }
    )

    // å„²å­˜çŸ¥è­˜
    for (const knowledge of result.knowledge) {
      knowledgeExtractor.saveKnowledge(knowledge)
    }

    res.json({
      success: true,
      result
    })
  } catch (error) {
    console.error('[knowledge] Extract error:', error)
    res.status(500).json({ success: false, error: 'Failed to extract knowledge' })
  }
})

app.get('/api/knowledge', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const catId = typeof req.query.catId === 'string' ? req.query.catId : 'default'
    const limitParam = typeof req.query.limit === 'string' ? parseInt(req.query.limit, 10) : 50
    const limit = Number.isFinite(limitParam) ? Math.max(1, Math.min(200, limitParam)) : 50

    const knowledge = knowledgeExtractor.getCatKnowledge(catId, limit)

    res.json({
      success: true,
      knowledge
    })
  } catch (error) {
    console.error('[knowledge] List error:', error)
    res.status(500).json({ success: false, error: 'Failed to list knowledge' })
  }
})

app.patch('/api/knowledge/:id', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const { id } = req.params
    const updates = req.body

    knowledgeExtractor.updateKnowledge(id, updates)

    res.json({ success: true })
  } catch (error) {
    console.error('[knowledge] Update error:', error)
    res.status(500).json({ success: false, error: 'Failed to update knowledge' })
  }
})

app.delete('/api/knowledge/:id', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const { id } = req.params
    knowledgeExtractor.deleteKnowledge(id)

    res.json({ success: true })
  } catch (error) {
    console.error('[knowledge] Delete error:', error)
    res.status(500).json({ success: false, error: 'Failed to delete knowledge' })
  }
})

app.get('/api/knowledge/stats', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const catId = typeof req.query.catId === 'string' ? req.query.catId : undefined
    const stats = knowledgeExtractor.getKnowledgeStats(catId)

    res.json({
      success: true,
      stats
    })
  } catch (error) {
    console.error('[knowledge] Stats error:', error)
    res.status(500).json({ success: false, error: 'Failed to get stats' })
  }
})

// ==================== ä¸»å‹•æ´žå¯Ÿ API ====================

app.get('/api/insights', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const catId = typeof req.query.catId === 'string' ? req.query.catId : undefined
    const insights = proactiveAssistant.getActiveInsights(catId)

    res.json({
      success: true,
      insights
    })
  } catch (error) {
    console.error('[insights] List error:', error)
    res.status(500).json({ success: false, error: 'Failed to list insights' })
  }
})

app.post('/api/insights/check', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const catId = typeof req.body.catId === 'string' ? req.body.catId : undefined
    const result = await proactiveAssistant.checkProactiveInsights(catId)

    // å„²å­˜æ–°æ´žå¯Ÿ
    for (const insight of result.insights) {
      proactiveAssistant.saveInsight(insight)
    }

    res.json({
      success: true,
      result
    })
  } catch (error) {
    console.error('[insights] Check error:', error)
    res.status(500).json({ success: false, error: 'Failed to check insights' })
  }
})

app.post('/api/insights/:id/dismiss', async (req, res) => {
  if (!requireAuthenticated(req, res)) return

  try {
    const { id } = req.params
    proactiveAssistant.dismissInsight(id)

    res.json({ success: true })
  } catch (error) {
    console.error('[insights] Dismiss error:', error)
    res.status(500).json({ success: false, error: 'Failed to dismiss insight' })
  }
})

app.post('/api/equipment/test', (req, res) => {
  const equipmentId = (req.body?.id as string | undefined) ?? 'unknown'
  const defaultResponse: EquipmentTestResponse = {
    id: equipmentId,
    success: false,
    latencyMs: 0,
    messageKey: 'equipment.status.backendMissing',
  }

  if (equipmentId === 'arduino') {
    if (latestSnapshot) {
      const lastTimestamp = new Date(latestSnapshot.reading.timestamp).getTime()
      const delta = Date.now() - lastTimestamp
      const online = Number.isFinite(delta) && delta < 5 * 60 * 1000
      res.json({
        ok: true,
        data: {
          id: equipmentId,
          success: online,
          latencyMs: online ? delta : 0,
          messageKey: online ? 'equipment.status.ok' : 'equipment.status.fail',
        },
      })
      return
    }

    res.json({ ok: true, data: { ...defaultResponse, messageKey: 'equipment.status.fail' } })
    return
  }

  res.json({ ok: true, data: defaultResponse })
})

// ðŸ”’ å° AI èŠå¤©ç«¯é»žå¥—ç”¨ç‰¹æ®Šé€ŸçŽ‡é™åˆ¶ (Apply special rate limit to AI chat)
app.post('/api/chat/suggestions', chatLimiter, async (req, res) => {
  const requestId = Math.random().toString(36).slice(2)
  console.log(`[chat] ${requestId} start`)
  if (!requireAuthenticated(req, res)) {
    return
  }
  const isDeveloper = req.authUser.role === 'developer'

  // æª¢æŸ¥æ˜¯å¦ç‚º SSE è«‹æ±‚ - æ­¤ç«¯é»žéœ€è¦ SSE
  const acceptHeader = typeof req.headers.accept === 'string' ? req.headers.accept : ''
  if (!acceptHeader.includes('text/event-stream')) {
    res.status(400).json({ ok: false, message: 'This endpoint requires SSE. Use Accept: text/event-stream header or use /api/chat/stream instead.' })
    return
  }

  // å‰µå»º SSE é€£æŽ¥
  const connectionId = typeof req.body?.connectionId === 'string' && req.body.connectionId.trim().length > 0
    ? req.body.connectionId.trim()
    : requestId
  const connection = globalSSEPool.createConnection(res, connectionId)

  if (!connection) {
    res.status(503).json({ ok: false, message: 'sse-connection-limit' })
    return
  }

  try {
    const requestedLanguage = typeof req.body?.language === 'string' ? req.body.language : undefined
    const rememberLanguage = req.body?.rememberLanguage === true
    const resolvedLanguage = resolveRequestLanguage(requestedLanguage)
    if (rememberLanguage && (requestedLanguage === 'zh' || requestedLanguage === 'en')) {
      setPersistedLanguage(requestedLanguage)
    }

    await runWithLanguageContext(resolvedLanguage, async () => {
      let modelPreference = (() => {
        if (typeof req.body?.modelPreference !== 'string') return undefined
        const raw = req.body.modelPreference.trim().toLowerCase()
        if (['pro', 'expert', 'advanced', 'better', 'smarter', 'bigger'].includes(raw)) return 'pro' as const
        if (['standard', 'balanced', 'default', 'regular'].includes(raw)) return 'standard' as const
        if (['auto', 'smart', 'adaptive'].includes(raw)) return 'auto' as const
        return undefined
      })()

      const reasoningEffort = (() => {
        if (typeof req.body?.reasoningEffort !== 'string') return undefined
        const raw = req.body.reasoningEffort.trim().toLowerCase()
        if (raw === 'low' || raw === 'medium' || raw === 'high') return raw as ReasoningEffort
        return undefined
      })()

      let enableSearch = (() => {
        const raw = req.body?.enableSearch
        if (typeof raw === 'boolean') return raw
        if (typeof raw === 'string') {
          const normalized = raw.trim().toLowerCase()
          if (['1', 'true', 'yes', 'on'].includes(normalized)) return true
          if (['0', 'false', 'no', 'off'].includes(normalized)) return false
        }
        return false
      })()

      const requestIntentRaw =
        typeof req.body?.intent === 'string' ? req.body.intent.trim().toLowerCase() : ''
      const isMcpIntent = requestIntentRaw === 'mcp'

    const requestedCatId = typeof req.body?.catId === 'string' && req.body.catId.trim().length > 0 ? req.body.catId.trim() : activeCatId
    const initialSnapshotRaw = latestSnapshotsByCat.get(requestedCatId) ?? loadLatestSnapshot(requestedCatId)
    const initialSnapshot = initialSnapshotRaw
      ? initialSnapshotRaw.catId
        ? initialSnapshotRaw
        : { ...initialSnapshotRaw, catId: requestedCatId }
      : null
    if (initialSnapshot) {
      latestSnapshotsByCat.set(requestedCatId, initialSnapshot)
    }

    const rawMessages: unknown[] = Array.isArray(req.body?.messages) ? req.body.messages : []
    const {
      conversationMessages,
      imageAttachments: parsedImageAttachments,
      documentAttachments,
    } = parseConversationAttachments(rawMessages)
    const imageAttachments = parsedImageAttachments.map(({ messageIndex: _index, ...rest }) => rest)
    const latestAttachment = imageAttachments.length > 0 ? imageAttachments[imageAttachments.length - 1] : null
    const lastMessage = findLastMessageByRole(conversationMessages, 'user')
    let question = typeof lastMessage?.content === 'string' ? lastMessage.content : ''
    const trimmedQuestion = question.trim().toLowerCase()
    const needsDefaultPrompt =
      trimmedQuestion.length === 0 ||
      trimmedQuestion === '[image]' ||
      trimmedQuestion === '(image)' ||
      trimmedQuestion === 'image'

    if (needsDefaultPrompt) {
      question = getPreferredLanguage() === 'en'
        ? 'Please review the latest photo and share actionable, friendly cat-care guidance.'
        : 'è«‹é‡å°å‰›æ‰ä¸Šå‚³çš„ç…§ç‰‡ï¼Œèªªæ˜Žä½ è§€å¯Ÿåˆ°çš„é‡é»žï¼Œä¸¦æä¾›å¯¦ç”¨ã€æº«æš–çš„ç…§è­·å»ºè­°ã€‚'
      if (lastMessage) {
        lastMessage.content = question
      } else {
        conversationMessages.push({ role: 'user', content: question })
      }
    }

    const userRequestedSearch = !isMcpIntent && indicatesWebSearch(question)
    if (userRequestedSearch && !enableSearch) {
      enableSearch = true
      if (!modelPreference || modelPreference === 'auto') {
        modelPreference = 'pro'
      }
      console.log(`[chat] ${requestId} auto-enabled simple search based on user intent.`)
    }

    if (enableSearch && (!modelPreference || modelPreference === 'auto')) {
      modelPreference = 'pro'
    }

    const streamingUserRequestedSearchHint = !isMcpIntent && indicatesWebSearch(question)
    if (streamingUserRequestedSearchHint && !enableSearch) {
      enableSearch = true
      if (!modelPreference || modelPreference === 'auto') {
        modelPreference = 'pro'
      }
      console.log(`[chat-stream] ${requestId} auto-enabled simple search based on user intent.`)
    }

    // ðŸ”¹ ç¬¬2éšŽæ®µï¼šèª¿ç”¨è¨˜æ†¶å’Œæ­·å²
    connection?.sendPhase('retrieving_memory', 'Loading memories and history...')

    let snapshotForChat = initialSnapshot
    let history = loadHistory(HISTORY_LIMIT, requestedCatId)
    const relevantMemories = loadRelevantMemories(question, 5)
    const toolEvents: ToolExecutionLog[] = []
    let documentSummary: string | null = null
    if (documentAttachments.length > 0) {
      for (const docAttachment of documentAttachments) {
        const validation = validateDocumentUpload({
          dataUrl: docAttachment.dataUrl,
          mimeType: docAttachment.mimeType,
          filename: docAttachment.filename,
        })
        if (!validation.ok) {
          console.warn(`[chat-stream] Document validation failed: ${validation.message}`)
          connection?.sendError(validation.message, validation.error ?? 'invalid-document')
          connection.close()
          globalSSEPool.closeConnection(connectionId)
          return
        }
        try {
          const summary = await summarizeDocumentAttachmentBeforeChat({
            attachment: {
              dataUrl: validation.value.dataUrl,
              mimeType: validation.value.mimeType,
              filename: validation.value.filename ?? docAttachment.filename,
              type: docAttachment.type,
            },
            requestedCatId,
            userId: req.authUser.username,
            toolEvents,
            connection,
          })
          documentSummary = documentSummary ? `${documentSummary}\n\n${summary}` : summary
        } catch (error) {
          console.error('[document] Attachment processing failed', error)
          connection?.sendError(
            error instanceof Error ? error.message : 'document-processing-failed',
            'document-error',
          )
          connection.close()
          globalSSEPool.closeConnection(connectionId)
          return
        }
      }
    }
    if (documentSummary) {
      conversationMessages.push({ role: 'system', content: documentSummary })
    }

    const hasImageAttachment = imageAttachments.length > 0
    let visionSummary: string | null = null

    if (hasImageAttachment) {
      connection?.sendPhase(
        'executing_tool',
        getPreferredLanguage() === 'en' ? 'Analyzing photo...' : 'æ­£åœ¨è§£æžç…§ç‰‡...',
      )
      const visionPrefetch = await analyzeImageAttachmentsBeforeChat({
        attachments: imageAttachments,
        question,
        language: getPreferredLanguage(),
        toolEvents,
        connection,
      })
      if (visionPrefetch.directResponse) {
        console.log('[VISION DEBUG] visionPrefetch.directResponse received:', {
          responseLength: visionPrefetch.directResponse.length,
          responsePreview: visionPrefetch.directResponse.substring(0, 100) + '...'
        })
        const responseText = limitResponseLength(
          ensureFriendlyClosing(visionPrefetch.directResponse, getPreferredLanguage()),
          getPreferredLanguage(),
        )
        console.log('[VISION DEBUG] After processing, responseText:', {
          responseLength: responseText.length,
          responsePreview: responseText.substring(0, 100) + '...'
        })
        connection?.sendPhase('streaming_text', getPreferredLanguage() === 'en' ? 'Streaming response...' : 'è¼¸å‡ºå›žè¦†ä¸­...')
        await TextStreamer.streamText(connection, responseText, 30)

        // ðŸ”§ FIX: Wait a bit before sending done to ensure all tokens are flushed
        await new Promise(resolve => setTimeout(resolve, 100))

        connection?.sendDone({ provider: 'local', modelTier: 'standard', toolEvents })

        // ðŸ”§ FIX: Wait before closing connection to ensure done event is sent
        await new Promise(resolve => setTimeout(resolve, 50))

        globalSSEPool.closeConnection(connectionId)
        console.log(`[chat-stream] ${requestId} completed via vision-only response`)
        return
      }
      visionSummary = visionPrefetch.summary

      // ðŸ”´ CRITICAL: Embed vision summary directly into user question
      if (visionSummary) {
        const photoKeywords = ['ç…§ç‰‡', 'åœ–ç‰‡', 'å›¾ç‰‡', 'ç›¸ç‰‡', 'photo', 'image', 'picture']
        const hasPhotoReference = photoKeywords.some(kw => question.toLowerCase().includes(kw.toLowerCase()))

        if (hasPhotoReference) {
          const rewritten = getPreferredLanguage() === 'en'
            ? `Here is what I see in the photo:

${visionSummary}

Please:
1. First, briefly describe what you see in 1-2 sentences
2. Then give 3-4 practical care tips (keep it concise and friendly)`
            : `é€™æ˜¯æˆ‘åœ¨ç…§ç‰‡ä¸­çœ‹åˆ°çš„ï¼š

${visionSummary}

è«‹ï¼š
1. é¦–å…ˆï¼Œç”¨1-2å¥è©±ç°¡çŸ­æè¿°ä½ çœ‹åˆ°çš„ç•«é¢
2. ç„¶å¾Œçµ¦å‡º3-4å€‹å¯¦ç”¨çš„ç…§è­·å»ºè­°ï¼ˆä¿æŒç°¡æ½”æº«æš–ï¼‰`

          console.log('[VISION DEBUG] (streaming) Embedding vision into user question:', {
            original: question.substring(0, 100),
            visionSummaryLength: visionSummary.length,
            newQuestionLength: rewritten.length,
            reason: 'Directly embed vision analysis into user message'
          })

          question = rewritten
          if (lastMessage) lastMessage.content = question
        }
      }

      connection?.sendPhase(
        'generating_response',
        getPreferredLanguage() === 'en' ? 'Merging vision context...' : 'æ•´åˆè¦–è¦ºçµæžœ...',
      )
    }

    // ðŸ”¹ ç¬¬3éšŽæ®µï¼šç”Ÿæˆå›žæ‡‰
    connection?.sendPhase('generating_response', 'Generating AI response...')

    let pendingSearchHint = streamingUserRequestedSearchHint
    let remainingSearchCalls = MAX_SEARCH_CALLS_PER_REQUEST
    let lastSearchOutput: string | null = null

    let chatResult = await generateChatContent({
      question,
      language: getPreferredLanguage(),
      snapshot: snapshotForChat,
      history,
      catId: requestedCatId,
      originalMessages: conversationMessages,
      hasImageAttachment,
      hasDocumentAttachment: Boolean(documentSummary),
      documentSummary,
      visionSummary,
      memories: relevantMemories,
      ...(modelPreference ? { modelPreference } : {}),
      ...(reasoningEffort ? { reasoningEffort } : {}),
      enableSearch,
      isDeveloperMode: isDeveloper,
      userRequestedSearch: pendingSearchHint,
    })

    // å·¥å…·èª¿ç”¨è¿­ä»£å¾ªç’°
    let iterations = 0
    let historyNeedsRefresh = false
    let overrideResponse: { text: string; skipClosing?: boolean } | null = null

    // ðŸ”§ FIX: Track tool calls to detect duplicates and prevent infinite loops
    const executedToolCalls = new Set<string>()
    let consecutiveFailures = 0
    const MAX_CONSECUTIVE_FAILURES = 2

    while (chatResult.toolCall && iterations < MAX_TOOL_CALL_ITERATIONS) {
      const toolCall = chatResult.toolCall
      const isSearchTool = SEARCH_TOOL_NAMES.has(toolCall.tool)
      connection?.sendPhase('executing_tool', `Executing tool: ${toolCall.tool}...`)

      const toolArgsForHistory = toolCall.args ?? {}

      // ðŸ”§ FIX: Generate unique key for this tool call (tool name + normalized args)
      const toolCallKey = `${toolCall.tool}:${JSON.stringify(toolCall.args || {})}`

      // ðŸ”§ FIX: Check for duplicate tool calls
      if (executedToolCalls.has(toolCallKey)) {
        const language = getPreferredLanguage()
        const duplicateMessage =
          language === 'en'
            ? `I've already tried searching for that information, but couldn't find specific results. Let me provide general guidance based on standard cat care principles instead.`
            : `æˆ‘å·²ç¶“å˜—è©¦æœå°‹éŽç›¸é—œè³‡è¨Šä½†æœªèƒ½æ‰¾åˆ°å…·é«”çµæžœï¼Œè®“æˆ‘æ ¹æ“šæ¨™æº–è²“å’ªç…§è­·åŽŸå‰‡ç‚ºæ‚¨æä¾›é€šç”¨å»ºè­°ã€‚`
        console.log(`[ai] Detected duplicate tool call: ${toolCall.tool}, stopping iteration (iteration ${iterations})`)
        connection?.sendTool(toolCall.tool, toolCall.args, { error: duplicateMessage })
        overrideResponse = { text: duplicateMessage, skipClosing: false }
        break
      }
      executedToolCalls.add(toolCallKey)

      if (isSearchTool && remainingSearchCalls <= 0) {
        const language = getPreferredLanguage()
        const limitInstruction =
          language === 'en'
            ? 'You have reached the per-request search quota. Begin your reply by noting you will use the findings already gathered, then convert the summary below into 3-4 actionable tips that answer the question. Reference notable sources inline (e.g., (ASPCA)) and do not ask for additional searches.'
            : 'æœ¬è¼ªæœå°‹é¡åº¦å·²ç”¨ç½„ã€‚è«‹å…ˆèªªæ˜Žæœƒæ”¹ç”¨ç¾æœ‰æœå°‹çµæžœï¼Œå†æ ¹æ“šä¸‹æ–¹æ‘˜è¦æ•´ç† 3-4 å€‹å¯åŸ·è¡Œå»ºè­°ä»¥å›žç­”å•é¡Œï¼Œå¿…è¦æ™‚ä»¥æ‹¬è™Ÿæ¨™è¨»è³‡æ–™ä¾†æºï¼ˆå¦‚ï¼š(ASPCA)ï¼‰ï¼Œä¸”ä¸è¦å†è¦æ±‚æœå°‹ã€‚'
        if (lastSearchOutput && lastSearchOutput.trim()) {
          connection?.sendTool(toolCall.tool, toolCall.args, {
            error:
              language === 'en'
                ? 'Search quota reached; reusing collected findings.'
                : 'æœå°‹é¡åº¦å·²é”ä¸Šé™ï¼Œæ”¹ç”¨æ—¢æœ‰çµæžœã€‚',
          })
          conversationMessages.push({ role: 'system', content: limitInstruction })
          conversationMessages.push({
            role: 'assistant',
            content:
              language === 'en'
                ? `ðŸ”Ž Search summary:\n${lastSearchOutput}`
                : `ðŸ”Ž æœå°‹æ‘˜è¦ï¼š\n${lastSearchOutput}`,
          })
          pendingSearchHint = false
          enableSearch = false
          chatResult = await generateChatContent({
            question,
            language,
            snapshot: snapshotForChat,
            history,
            catId: requestedCatId,
            originalMessages: conversationMessages,
            hasImageAttachment,
            visionSummary,
            memories: relevantMemories,
            ...(modelPreference ? { modelPreference } : {}),
            ...(reasoningEffort ? { reasoningEffort } : {}),
            enableSearch,
            isDeveloperMode: isDeveloper,
            userRequestedSearch: false,
          })
          iterations += 1
          continue
        }
        const limitMessage =
          language === 'en'
            ? 'I already gathered online sources for this request, so I will finish the answer with those findings.'
            : 'æœ¬è¼ªå…è¨±çš„æœå°‹æ¬¡æ•¸å·²é”ä¸Šé™ï¼Œæˆ‘æœƒæ”¹ç”¨æ—¢æœ‰çš„è³‡æ–™æ•´ç†å›žè¦†ï¼Œä¸å†é‡æ–°æœå°‹ã€‚'
        connection?.sendTool(toolCall.tool, toolCall.args, { error: limitMessage })
        overrideResponse = { text: limitMessage, skipClosing: false }
        pendingSearchHint = false
        break
      }

      if (isSearchTool && !enableSearch) {
        const startedAt = Date.now()
        const logMessage =
          getPreferredLanguage() === 'en'
            ? 'Web search disabled for this request. Please enable the search toggle and switch to the pro model before trying again.'
            : 'æœ¬æ¬¡å°è©±çš„ç¶²é æœå°‹å·²é—œé–‰ï¼Œè«‹é–‹å•Ÿæœå°‹æ¨¡å¼ä¸¦åˆ‡æ›è‡³ Pro æ¨¡åž‹å¾Œå†è©¦ã€‚'
        const log: ToolExecutionLog = {
          tool: 'searchWeb',
          success: false,
          message: logMessage,
          args: toolArgsForHistory,
          durationMs: Date.now() - startedAt,
        }
        toolEvents.push(log)
        recordToolEvent(log)
        connection?.sendTool(toolCall.tool, toolCall.args, { error: logMessage })
        overrideResponse = { text: logMessage, skipClosing: false }
        break
      }

      const execution = await executeToolCall(toolCall, {
        modelTier: chatResult.modelTier ?? null,
        userQuestion: question,
        imageAttachment: latestAttachment,
        enableSearch,
        language: getPreferredLanguage(),
      })
      console.log(
        `[chat-stream] ${requestId} tool ${toolCall.tool} -> ${execution.log.success ? 'success' : 'fail'} (${execution.log.durationMs ?? 0}ms)`,
      )
      toolEvents.push(execution.log)
      recordToolEvent(execution.log)
      connection?.sendTool(toolCall.tool, toolCall.args, execution.log)

      if (toolCall.tool === 'switchToProModel' && execution.log.success) {
        modelPreference = 'pro'
      }

      // ðŸ”§ FIX: Detect empty or failed results BEFORE processing search tool output
      // This prevents setting lastSearchOutput with empty results
      // Check if search tool returned no useful results (handles both plain text and JSON responses)

      // ðŸ” DEBUG: Log detection attempt
      if (isSearchTool && execution.log.success) {
        console.log(`[ai] DEBUG: Checking if tool ${toolCall.tool} returned empty result`)
        console.log(`[ai] DEBUG: Output preview: ${(execution.log.output || '').substring(0, 200)}...`)
        console.log(`[ai] DEBUG: Output length: ${(execution.log.output || '').length}`)
      }

      const hasEmptyOrUselessResult =
        execution.log.success &&
        isSearchTool &&
        (() => {
          const output = execution.log.output
          if (!output || output.trim().length < 10) {
            console.log(`[ai] Tool ${toolCall.tool} returned null or very short output`)
            return true
          }

          // ðŸ”§ FIX: Check for common "no results" patterns in plain text
          const lowerOutput = output.toLowerCase()
          const noResultPatterns = [
            /no\s+(relevant\s+)?(results?|matches?|information|resources?|data)\s+(found|available|came up)/i,
            /couldn['']t\s+find\s+(any|specific|relevant)/i,
            /unable\s+to\s+(find|locate|retrieve)/i,
            /search\s+returned\s+(no|empty)/i,
            /æ²’æœ‰.*?(çµæžœ|è³‡è¨Š|è³‡æ–™)/,
            /æ‰¾ä¸åˆ°.*?(ç›¸é—œ|å…·é«”)/,
            /æœå°‹.*?(ç‚ºç©º|å¤±æ•—|ç„¡çµæžœ)/,
          ]

          for (const pattern of noResultPatterns) {
            if (pattern.test(lowerOutput)) {
              console.log(`[ai] Tool ${toolCall.tool} output contains "no results" pattern: ${pattern}`)
              return true
            }
          }

          // ðŸ”§ FIX: Check if MCP response is a JSON with empty results
          try {
            const parsed = JSON.parse(output.trim())
            console.log(`[ai] DEBUG: Successfully parsed JSON, checking for empty arrays`)
            // Check for common empty result patterns in MCP responses
            if (parsed.results && Array.isArray(parsed.results) && parsed.results.length === 0) {
              console.log(`[ai] Tool ${toolCall.tool} returned JSON with empty results array`)
              return true
            }
            if (parsed.items && Array.isArray(parsed.items) && parsed.items.length === 0) {
              console.log(`[ai] Tool ${toolCall.tool} returned JSON with empty items array`)
              return true
            }
            // Check for explicit "no results" messages in JSON
            if (parsed.message && /no.*(result|match|found)/i.test(parsed.message)) {
              console.log(`[ai] Tool ${toolCall.tool} returned "no results" message in JSON`)
              return true
            }
            console.log(`[ai] DEBUG: JSON has content, not empty`)
          } catch (e) {
            console.log(`[ai] DEBUG: JSON parse failed, checking for truncated JSON`)
            // Not valid JSON - check if it looks like truncated JSON with empty results
            if (output.includes('"results": []') || output.includes('"items": []')) {
              console.log(`[ai] Tool ${toolCall.tool} returned truncated JSON with empty array`)
              return true
            }

            // Not JSON, check plain text length as last resort
            if (output.trim().length < 50) {
              console.log(`[ai] Tool ${toolCall.tool} returned very short plain text (${output.trim().length} chars)`)
              return true
            }
            console.log(`[ai] DEBUG: Output is not JSON and not empty (length: ${output.trim().length})`)
          }

          // ðŸ”§ NEW FIX: Check for IRRELEVANT results (not just empty results)
          // If the search returned content but it's about a completely different topic,
          // treat it as useless. This catches cases like searching "suzumi cat" but
          // getting results about "Nick Suzuki" (hockey player) or "Arctic Cat" (snowmobiles).
          const queryText = (toolCall.args?.query || toolCall.args?.q || '').toString().toLowerCase()
          if (queryText && output.length > 100) {
            console.log(`[ai] DEBUG: Checking relevance for query: "${queryText}"`)

            // Extract meaningful keywords (ignore common words, length > 2)
            const stopWords = new Set(['the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'be', 'how', 'what', 'when', 'where', 'why', 'who', 'can', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under', 'over'])
            const queryKeywords = queryText
              .split(/[\s\-_,\.]+/)
              .filter(word => word.length > 2 && !stopWords.has(word))

            console.log(`[ai] DEBUG: Query keywords to check: ${JSON.stringify(queryKeywords)}`)

            if (queryKeywords.length > 0) {
              // Check how many query keywords appear in the output
              const matchedKeywords = queryKeywords.filter(keyword => {
                const found = lowerOutput.includes(keyword)
                console.log(`[ai] DEBUG: Checking keyword "${keyword}" in output: ${found}`)
                return found
              })

              const matchRatio = matchedKeywords.length / queryKeywords.length
              console.log(`[ai] DEBUG: Keyword match ratio: ${matchedKeywords.length}/${queryKeywords.length} (${(matchRatio * 100).toFixed(1)}%)`)

              // ðŸ”§ CRITICAL FIX: Multi-layer relevance checking
              // 1. First check: If less than 70% of keywords match, likely irrelevant
              //    (Raised from 50% because common words like "cat", "take", "care" can appear in unrelated content)
              if (matchRatio < 0.7) {
                console.log(`[ai] Tool ${toolCall.tool} returned IRRELEVANT results (only ${(matchRatio * 100).toFixed(1)}% of query keywords found, threshold is 70%)`)
                console.log(`[ai] DEBUG: Matched keywords: ${JSON.stringify(matchedKeywords)}`)
                console.log(`[ai] DEBUG: This likely means search proxy returned wrong results`)
                return true
              }

              // 2. Second check: If query has specialized terms (length > 5 or capitalized),
              //    at least ONE specialized term must match
              const originalQuery = (toolCall.args?.query || toolCall.args?.q || '').toString()
              const queryWords = originalQuery.split(/[\s\-_,\.]+/)
              const specializedTerms = queryKeywords.filter((word, idx) => {
                const originalWord = queryWords[idx] || ''
                // A term is "specialized" if: length > 5, OR starts with capital letter
                return word.length > 5 || /^[A-Z]/.test(originalWord)
              })

              if (specializedTerms.length > 0) {
                const hasSpecializedMatch = specializedTerms.some(term => lowerOutput.includes(term))
                console.log(`[ai] DEBUG: Specialized terms in query: ${JSON.stringify(specializedTerms)}`)
                console.log(`[ai] DEBUG: At least one specialized term matched: ${hasSpecializedMatch}`)

                if (!hasSpecializedMatch) {
                  console.log(`[ai] Tool ${toolCall.tool} returned IRRELEVANT results (no specialized terms matched)`)
                  console.log(`[ai] DEBUG: Example: searching "suzumi cat" but got "Arctic Cat" snowmobile or "Nick Suzuki" hockey player`)
                  return true
                }
              }

              console.log(`[ai] DEBUG: ${(matchRatio * 100).toFixed(1)}% of keywords found, results appear relevant`)
            }
          }

          console.log(`[ai] DEBUG: No empty result patterns matched`)
          return false
        })()

      console.log(`[ai] DEBUG: hasEmptyOrUselessResult = ${hasEmptyOrUselessResult}`)

      if (hasEmptyOrUselessResult) {
        consecutiveFailures += 1
        console.log(`[ai] Tool ${toolCall.tool} returned empty/useless result (iteration ${iterations}), consecutive failures: ${consecutiveFailures}`)
      } else if (execution.log.success) {
        consecutiveFailures = 0  // Reset on successful result with useful output
      }

      // ðŸ”§ FIX: Process search tool output ONLY if result is not empty
      // This ensures we only save useful search results
      if (isSearchTool && execution.log.success && !hasEmptyOrUselessResult) {
        remainingSearchCalls = Math.max(0, remainingSearchCalls - 1)
        pendingSearchHint = false

        // Save the search output and add system message
        if (execution.log.output && execution.log.output.trim()) {
          lastSearchOutput = execution.log.output
          const summary =
            getPreferredLanguage() === 'en'
              ? `ðŸ”Ž Search completed successfully. Results:\n${execution.log.output}\n\nâœ… IMPORTANT: You must now answer the user's question using ONLY these search results. Do NOT call searchWeb again.`
              : `ðŸ”Ž æœå°‹å®Œæˆã€‚çµæžœï¼š\n${execution.log.output}\n\nâœ… é‡è¦ï¼šè«‹ç«‹å³ä½¿ç”¨ä»¥ä¸Šæœå°‹çµæžœå›žç­”ä½¿ç”¨è€…å•é¡Œã€‚ç¦æ­¢å†æ¬¡å‘¼å« searchWebã€‚`
          conversationMessages.push({ role: 'system', content: summary })
        }

        // Disable search after successful call to prevent infinite loops
        enableSearch = false

        if (remainingSearchCalls === 0) {
          conversationMessages.push({
            role: 'system',
            content:
              getPreferredLanguage() === 'en'
                ? 'No further searches are allowed in this request. Summarise the findings you already collected.'
                : 'æœ¬æ¬¡å°è©±å·²ç¶“å®Œæˆæ‰€æœ‰æœå°‹ï¼Œè«‹ä¾ç¾æœ‰çµæžœçµ¦å‡ºçµè«–ï¼Œä¸è¦å†æœå°‹ã€‚',
          })
          pendingSearchHint = false
          enableSearch = false
        }
      }

      // ðŸ”§ FIX: Stop after MAX_CONSECUTIVE_FAILURES empty/failed results
      if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {
        const language = getPreferredLanguage()
        console.log(`[ai] Reached MAX_CONSECUTIVE_FAILURES (${MAX_CONSECUTIVE_FAILURES}), stopping search loop`)

        // ðŸ”§ CRITICAL: Clean search hints from question and conversation messages
        // Since enableSearch=false, searchWeb won't be in tool list, but frontend hints remain
        // This prevents model confusion about "missing searchWeb tool"
        const cleanedQuestion = question
          .replace(/ï¼ˆæœ¬è¼ªå•Ÿç”¨è¯ç¶²æœå°‹ï¼Œè«‹å‹™å¿…å…ˆå‘¼å« searchWeb å·¥å…·æª¢ç´¢å¾Œå†å›žç­”ï¼Œè‹¥æœå°‹å¤±æ•—è«‹æ˜Žç¢ºèªªæ˜ŽåŽŸå› ã€‚ï¼‰/g, '')
          .replace(/\(This round has web search enabled.*?must call searchWeb tool.*?\)/gi, '')
          .replace(/\(Web search is enabled.*?explain if the search fails\.\)/gi, '')
          .trim()

        const cleanedMessages = conversationMessages.map((msg) => {
          if (msg.role !== 'user') return msg
          const cleanedContent = msg.content
            .replace(/ï¼ˆæœ¬è¼ªå•Ÿç”¨è¯ç¶²æœå°‹ï¼Œè«‹å‹™å¿…å…ˆå‘¼å« searchWeb å·¥å…·æª¢ç´¢å¾Œå†å›žç­”ï¼Œè‹¥æœå°‹å¤±æ•—è«‹æ˜Žç¢ºèªªæ˜ŽåŽŸå› ã€‚ï¼‰/g, '')
            .replace(/\(This round has web search enabled.*?must call searchWeb tool.*?\)/gi, '')
            .replace(/\(Web search is enabled.*?explain if the search fails\.\)/gi, '')
            .trim()
          return cleanedContent !== msg.content ? { ...msg, content: cleanedContent } : msg
        })

        console.log(`[ai] Cleaned search hints before final response (question changed: ${cleanedQuestion !== question})`)

        cleanedMessages.push({
          role: 'system',
          content:
            language === 'en'
              ? 'Multiple search attempts yielded no useful results. Provide general cat care advice based on your knowledge instead. Do NOT attempt to search again. Give 3-4 practical tips.'
              : 'å¤šæ¬¡æœå°‹å‡æœªç²å¾—æœ‰ç”¨çµæžœã€‚è«‹æ”¹ç”¨ä½ çš„çŸ¥è­˜æä¾›ä¸€èˆ¬æ€§è²“å’ªç…§è­·å»ºè­°ã€‚ä¸è¦å†å˜—è©¦æœå°‹ã€‚çµ¦å‡º 3-4 å€‹å¯¦ç”¨å»ºè­°ã€‚',
        })

        // ðŸ”§ FIX: Let the model generate a complete response with advice
        // instead of using overrideResponse which just shows a short message
        chatResult = await generateChatContent({
          question: cleanedQuestion,  // Use cleaned question without search hints
          language: getPreferredLanguage(),
          snapshot: snapshotForChat,
          history,
          catId: requestedCatId,
          originalMessages: cleanedMessages,  // Use cleaned messages
          hasImageAttachment,
          visionSummary,
          memories: relevantMemories,
          ...(modelPreference ? { modelPreference } : {}),
          ...(reasoningEffort ? { reasoningEffort } : {}),
          enableSearch: false,  // Disable search to prevent further tool calls
          isDeveloperMode: isDeveloper,
          userRequestedSearch: false,
        })
        // Exit the tool loop - the model should provide direct text response now
        break
      }

      if (execution.log.success && execution.snapshot) {
        const normalizedSnapshot = execution.snapshot.catId
          ? execution.snapshot
          : { ...execution.snapshot, catId: requestedCatId }
        snapshotForChat = normalizedSnapshot
        await applySnapshot(normalizedSnapshot.catId ?? requestedCatId, normalizedSnapshot)
        historyNeedsRefresh = true
      }

      if (!execution.log.success) {
        consecutiveFailures += 1
        console.log(`[ai] Tool ${toolCall.tool} failed (iteration ${iterations}), consecutive failures: ${consecutiveFailures}`)

        if (consecutiveFailures >= MAX_CONSECUTIVE_FAILURES) {
          const language = getPreferredLanguage()
          console.log(`[ai] Reached MAX_CONSECUTIVE_FAILURES (${MAX_CONSECUTIVE_FAILURES}) due to tool failures`)
          conversationMessages.push({
            role: 'system',
            content:
              language === 'en'
                ? 'Multiple tool attempts failed. Provide general cat care advice based on your knowledge instead. Give 3-4 practical tips.'
                : 'å¤šæ¬¡å·¥å…·å‘¼å«å¤±æ•—ã€‚è«‹æ”¹ç”¨ä½ çš„çŸ¥è­˜æä¾›ä¸€èˆ¬æ€§è²“å’ªç…§è­·å»ºè­°ã€‚çµ¦å‡º 3-4 å€‹å¯¦ç”¨å»ºè­°ã€‚',
          })
          // Let the model generate a complete response
          chatResult = await generateChatContent({
            question,
            language: getPreferredLanguage(),
            snapshot: snapshotForChat,
            history,
            catId: requestedCatId,
            originalMessages: conversationMessages,
            hasImageAttachment,
            visionSummary,
            memories: relevantMemories,
            ...(modelPreference ? { modelPreference } : {}),
            ...(reasoningEffort ? { reasoningEffort } : {}),
            enableSearch: false,
            isDeveloperMode: isDeveloper,
            userRequestedSearch: false,
          })
          break
        }

        const failureResponse =
          getPreferredLanguage() === 'en'
            ? `I'm sorryâ€”the ${toolCall.tool} request failed: ${execution.log.message}. Please try again later or check your connection.`
            : `æŠ±æ­‰ï¼Œ${toolCall.tool} æ“ä½œå¤±æ•—ï¼š${execution.log.message}ï¼Œè«‹ç¨å¾Œå†è©¦æˆ–æª¢æŸ¥é€£ç·šã€‚`
        overrideResponse = { text: failureResponse, skipClosing: false }
        break
      }

      if (execution.directResponse) {
        const directResponse = execution.directResponse
        conversationMessages.push({
          role: 'assistant',
          content: directResponse,
        })
        overrideResponse = { text: directResponse, skipClosing: true }
        break
      }

      if (historyNeedsRefresh) {
        history = loadHistory(HISTORY_LIMIT, requestedCatId)
        historyNeedsRefresh = false
      }

      // ðŸ”§ CRITICAL FIX: Clean search hints from question AND conversation messages
      // Frontend embeds search instructions in BOTH the question AND the message history
      // Always clean when search is disabled, regardless of whether we got results
      // to prevent model confusion about missing searchWeb tool
      let questionForNextCall = question
      let messagesForNextCall = conversationMessages

      if (!enableSearch) {  // ðŸ”§ FIX: Remove lastSearchOutput condition - clean hints even if no results
        // Clean the question parameter
        questionForNextCall = question
          .replace(/ï¼ˆæœ¬è¼ªå•Ÿç”¨è¯ç¶²æœå°‹ï¼Œè«‹å‹™å¿…å…ˆå‘¼å« searchWeb å·¥å…·æª¢ç´¢å¾Œå†å›žç­”ï¼Œè‹¥æœå°‹å¤±æ•—è«‹æ˜Žç¢ºèªªæ˜ŽåŽŸå› ã€‚ï¼‰/g, '')
          .replace(/\(This round has web search enabled.*?must call searchWeb tool.*?\)/gi, '')
          .replace(/\(Web search is enabled.*?explain if the search fails\.\)/gi, '')
          .trim()

        // Clean ALL user messages in conversation history (not just the last one)
        // After tool execution, the array grows and the last message may not be a user message
        if (conversationMessages.length > 0) {
          messagesForNextCall = conversationMessages.map((msg) => {
            if (msg.role !== 'user') return msg
            const cleanedContent = msg.content
              .replace(/ï¼ˆæœ¬è¼ªå•Ÿç”¨è¯ç¶²æœå°‹ï¼Œè«‹å‹™å¿…å…ˆå‘¼å« searchWeb å·¥å…·æª¢ç´¢å¾Œå†å›žç­”ï¼Œè‹¥æœå°‹å¤±æ•—è«‹æ˜Žç¢ºèªªæ˜ŽåŽŸå› ã€‚ï¼‰/g, '')
              .replace(/\(This round has web search enabled.*?must call searchWeb tool.*?\)/gi, '')
              .replace(/\(Web search is enabled.*?explain if the search fails\.\)/gi, '')
              .trim()
            if (cleanedContent !== msg.content) {
              console.log(`[ai] Cleaned search hint from user message in conversation (iteration ${iterations})`)
              return { ...msg, content: cleanedContent }
            }
            return msg
          })
        }

        if (questionForNextCall !== question) {
          console.log(`[ai] Cleaned search hint from question for subsequent call`)
        }
      }

      chatResult = await generateChatContent({
        question: questionForNextCall,
        language: getPreferredLanguage(),
        snapshot: snapshotForChat,
        history,
        catId: requestedCatId,
        originalMessages: messagesForNextCall,
        hasImageAttachment,
        hasDocumentAttachment: Boolean(documentSummary),
        visionSummary,
        documentSummary,
        memories: relevantMemories,
        ...(modelPreference ? { modelPreference } : {}),
        ...(reasoningEffort ? { reasoningEffort } : {}),
        enableSearch,
        isDeveloperMode: isDeveloper,
        // ðŸ”§ FIX: Do NOT set userRequestedSearch on subsequent calls in tool loop
        // The model should focus on the search results, not the original search intent
        userRequestedSearch: false,
      })
      iterations += 1
    }

    // ðŸ”¹ ç¬¬4éšŽæ®µï¼šä¸²æµè¼¸å‡ºæ–‡æœ¬
    connection?.sendPhase('streaming_text', 'Streaming response...')

    let responseText = overrideResponse?.text ?? chatResult.text ?? ''
    if ((!responseText || !responseText.trim()) && lastSearchOutput) {
      responseText =
        getPreferredLanguage() === 'en'
          ? `Here are the findings I already gathered:\n${lastSearchOutput}`
          : `ä»¥ä¸‹ç‚ºå…ˆå‰æœå°‹æ•´ç†çš„å…§å®¹ï¼š\n${lastSearchOutput}`
    }
    if (!overrideResponse?.skipClosing) {
      responseText = ensureFriendlyClosing(responseText, getPreferredLanguage())
    }
    responseText = limitResponseLength(responseText, getPreferredLanguage())
    responseText = limitResponseLength(responseText, getPreferredLanguage())

    // é€å­—ä¸²æµç™¼é€
    await TextStreamer.streamText(connection, responseText, 30)

    // ç™¼é€å®Œæˆä¿¡è™Ÿ
    const developerGuideMessage =
      isDeveloper
        ? getPreferredLanguage() === 'en'
          ? 'ðŸ› ï¸ Developer mode: Review the model reasoning below and capture improvement ideas for Smart Cat Pro.'
          : 'ðŸ› ï¸ é–‹ç™¼è€…æ¨¡å¼ï¼šæª¢è¦–ä»¥ä¸‹æ¨¡åž‹æŽ¨ç†ï¼Œå”åŠ©æå‡º Smart Cat Pro çš„å„ªåŒ–å»ºè­°ã€‚'
        : null

    const developerPayload = isDeveloper
      ? {
          thinking: chatResult.thinking ?? null,
          guidance: developerGuideMessage,
      systemPrompt: sanitizeSystemPrompt(
        buildSystemPrompt(
          getPreferredLanguage(),
          chatResult.modelTier === 'pro' ? 'pro' : chatResult.modelTier === 'ultra' ? 'ultra' : 'standard',
          true,
        ),
      ),
          context: {
            snapshot: snapshotForChat
              ? {
                  temperature: snapshotForChat.reading.temperatureC,
                  humidity: snapshotForChat.reading.humidityPercent,
                  waterLevel: snapshotForChat.reading.waterLevelPercent ?? null,
                  catPresent: snapshotForChat.reading.catPresent ?? null,
                  timestamp: snapshotForChat.reading.timestamp,
                }
              : null,
            memoriesCount: relevantMemories.length,
            historyLength: history.length,
            hasImage: hasImageAttachment,
            visionSummary,
            documentSummary,
            catId: requestedCatId ?? null,
          },
          request: {
            model: chatResult.provider ?? 'unknown',
            tier: chatResult.modelTier ?? 'standard',
            modelPreference: modelPreference ?? 'auto',
            reasoningEffort: reasoningEffort ?? 'high',
            enableSearch: enableSearch ?? false,
          },
          metrics: {
            durationMs: chatResult.durationMs ?? null,
            promptTokens: chatResult.usage?.promptTokens,
            completionTokens: chatResult.usage?.completionTokens,
            reasoningTokens: chatResult.usage?.reasoningTokens,
            totalTokens: chatResult.usage?.totalTokens,
          },
        }
      : null

    console.log(`[chat-stream] ${requestId} developerPayload exists=${!!developerPayload}, hasMetrics=${!!(developerPayload?.metrics)}, hasTokens=${!!(developerPayload?.metrics?.totalTokens)}`)

    const donePayload: Record<string, unknown> = {
      provider: chatResult.provider,
      modelTier: chatResult.modelTier ?? null,
      toolEvents,
      text: responseText,
    }
    if (developerPayload) {
      donePayload.developer = developerPayload
    }
    connection?.sendDone(donePayload)
    globalSSEPool.closeConnection(connectionId)

    console.log(`[chat-stream] ${requestId} complete provider=${chatResult.provider}`)
    })
  } catch (error) {
    console.error(`[chat-stream] ${requestId} failed`, error)
    connection?.sendError(
      error instanceof Error ? error.message : 'chat-stream-generation-failed',
      'GENERATION_ERROR'
    )
    connection.close()
    globalSSEPool.closeConnection(connectionId)
  }
})

app.get('/api/ai/tts/voices', (req, res) => {
  if (!ENABLE_TTS) {
    res.status(503).json({ ok: false, message: 'tts-disabled' })
    return
  }
  res.json({ ok: true, data: listVoicePresets() })
})

app.post('/api/chat/stream', chatLimiter, async (req, res) => {
  const requestId = Math.random().toString(36).slice(2)
  console.log(`[chat-stream] ${requestId} start`)
  if (!requireAuthenticated(req, res)) {
    return
  }

  const acceptHeader = typeof req.headers.accept === 'string' ? req.headers.accept : ''
  if (!acceptHeader.includes('text/event-stream')) {
    res.status(400).json({ ok: false, message: 'sse-required' })
    return
  }

  const connectionId =
    typeof req.body?.connectionId === 'string' && req.body.connectionId.trim().length > 0
      ? req.body.connectionId
      : requestId
  const connection = globalSSEPool.createConnection(res, connectionId)
  if (!connection) {
    res.status(503).json({ ok: false, message: 'sse-connection-limit' })
    return
  }

  const forwardBody = { ...(req.body ?? {}) }
  delete forwardBody.connectionId
  delete forwardBody.developer
  delete forwardBody.enableSse

  const targetHost = req.get('host') ?? 'localhost'
  const targetProtocol = req.protocol || 'http'

  try {
    connection?.sendPhase('retrieving_memory', 'Forwarding request to chat suggestions...')

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    }
    if (typeof req.headers.cookie === 'string') {
      headers.cookie = req.headers.cookie
    }
    if (typeof req.headers.authorization === 'string') {
      headers.authorization = req.headers.authorization
    }

    const forwardResponse = await fetch(`${targetProtocol}://${targetHost}/api/chat/suggestions`, {
      method: 'POST',
      headers,
      body: JSON.stringify(forwardBody),
    })

    let parsed: any = null
    try {
      parsed = await forwardResponse.json()
    } catch (error) {
      console.error('[chat-stream] Failed to parse suggestions response', error)
    }

    if (!forwardResponse.ok || !parsed?.ok) {
      const message = parsed?.message ?? 'chat-stream-proxy-error'
      connection?.sendError(message, 'FORWARD_ERROR')
      return
    }

    const content =
      parsed.data?.choices?.[0]?.message?.content ??
      parsed.data?.text ??
      extractSuggestionText(parsed.data)

    connection?.sendPhase('streaming_text', 'Streaming response...')
    const finalText = ensureFriendlyClosing(content, getPreferredLanguage())
    await TextStreamer.streamText(connection, finalText, 30)

    connection?.sendDone({
      provider: parsed.data?.provider ?? null,
      modelTier: parsed.data?.modelTier ?? null,
      toolEvents: parsed.data?.toolEvents ?? [],
      text: finalText,
    })
  } catch (error) {
    console.error(`[chat-stream] ${requestId} proxy failed`, error)
    connection?.sendError(
      error instanceof Error ? error.message : 'chat-stream-proxy-error',
      'FORWARD_ERROR',
    )
  } finally {
    globalSSEPool.closeConnection(connectionId)
  }
})

function extractSuggestionText(data: any): string {
  if (!data) return ''
  if (typeof data === 'string') {
    return data.trim()
  }
  if (typeof data.text === 'string') {
    return data.text.trim()
  }
  return ''
}

// ðŸ”’ å° AI èŠå¤©ç«¯é»žå¥—ç”¨ç‰¹æ®Šé€ŸçŽ‡é™åˆ¶ (Apply special rate limit to AI chat)
app.post('/api/ai/tts', chatLimiter, async (req, res) => {
  if (!ENABLE_TTS) {
    res.status(503).json({ ok: false, message: 'tts-disabled' })
    return
  }

  if (!ensureAdminAuthorized(req, res)) {
    return
  }

  const { text, language, speakerId, voiceId, speed, volume } = req.body ?? {}

  if (typeof text !== 'string' || text.trim().length === 0) {
    res.status(400).json({ ok: false, message: 'tts-invalid-text' })
    return
  }

  try {
    const textToSpeak = text.trim()
    const ttsOptions: SynthesizeSpeechOptions = { text: textToSpeak }

    if (typeof language === 'string') {
      const normalizedLanguage = language.trim()
      if (normalizedLanguage.length > 0) {
        ttsOptions.language = normalizedLanguage
      }
    }

    if (typeof speakerId === 'string') {
      const normalizedSpeaker = speakerId.trim()
      if (normalizedSpeaker.length > 0) {
        ttsOptions.speakerId = normalizedSpeaker
      }
    }

    if (typeof voiceId === 'string' && voiceId.trim().length > 0) {
      ttsOptions.voiceId = voiceId.trim()
    }

    if (typeof speed === 'number' && Number.isFinite(speed)) {
      ttsOptions.speed = Math.min(Math.max(speed, 0.85), 1.2)
    }

    if (typeof volume === 'number' && Number.isFinite(volume)) {
      ttsOptions.volume = Math.min(Math.max(volume, 0.6), 1.5)
    }

    const result = await synthesizeSpeech(ttsOptions)

    const payload: TextToSpeechResponsePayload = {
      audioBase64: result.audioBase64,
      format: result.format,
      sampleRate: result.sampleRate,
      durationSeconds: result.durationSeconds,
    }
    if (result.voiceId) {
      payload.voiceId = result.voiceId
    }
    if (typeof result.playbackRate === 'number') {
      payload.playbackRate = result.playbackRate
    }

    res.json({
      ok: true,
      data: payload,
    })
  } catch (error) {
    console.error('[tts] synthesis failed', error)
    res.status(500).json({ ok: false, message: 'tts-failed' })
  }
})

// ==========================================
// ðŸ”’ å…¨åŸŸéŒ¯èª¤è™•ç† (Global Error Handlers)
// ==========================================

// è™•ç† 404 éŒ¯èª¤ï¼ˆæ‰¾ä¸åˆ°è·¯ç”±ï¼‰
// Handle 404 errors (route not found)
app.use((_req, res) => {
  res.status(404).json({
    ok: false,
    message: 'Route not found',
  })
})

// è™•ç†æ‰€æœ‰æœªæ•ç²çš„éŒ¯èª¤
// Handle all uncaught errors in routes
app.use((err: Error, _req: express.Request, res: express.Response, _next: express.NextFunction) => {
  console.error('[error] Unhandled error in route:', err)

  // æª¢æŸ¥æ˜¯å¦ç‚º CORS éŒ¯èª¤
  // Check if it's a CORS error
  if (err.message === 'Origin not allowed') {
    res.status(403).json({
      ok: false,
      message: 'Origin not allowed by CORS policy',
    })
    return
  }

  // å…¶ä»–éŒ¯èª¤å›žå‚³ 500
  // Return 500 for other errors
  res.status(500).json({
    ok: false,
    message: 'Internal server error',
    // åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ä¸è¦æ´©éœ²è©³ç´°éŒ¯èª¤è¨Šæ¯
    // Don't leak detailed error messages in production
    ...(process.env.NODE_ENV === 'development' && { error: err.message }),
  })
})

// è™•ç†æœªæ•ç²çš„ Promise æ‹’çµ•
// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('[fatal] Unhandled Rejection at:', promise, 'reason:', reason)
  // è¨˜éŒ„ä½†ä¸é€€å‡ºï¼Œè®“æ‡‰ç”¨ç¹¼çºŒé‹è¡Œ
  // Log but don't exit, let the application continue
})

// è™•ç†æœªæ•ç²çš„ç•°å¸¸
// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('[fatal] Uncaught Exception:', error)
  // æœªæ•ç²çš„ç•°å¸¸å¾ˆåš´é‡ï¼Œæ‡‰è©²å„ªé›…åœ°é—œé–‰
  // Uncaught exceptions are serious, should gracefully shutdown
  process.exit(1)
})

// å„ªé›…é—œé–‰è™•ç†
// Graceful shutdown handler
process.on('SIGTERM', () => {
  console.log('[shutdown] SIGTERM received, shutting down gracefully...')
  // é€™è£¡å¯ä»¥æ·»åŠ æ¸…ç†é‚è¼¯ï¼ˆé—œé–‰è³‡æ–™åº«é€£æŽ¥ç­‰ï¼‰
  // Add cleanup logic here (close DB connections, etc.)
  process.exit(0)
})

process.on('SIGINT', () => {
  console.log('[shutdown] SIGINT received, shutting down gracefully...')
  process.exit(0)
})

// ==========================================
// ä¼ºæœå™¨å•Ÿå‹• (Server Startup)
// ==========================================

const PORT = Number(process.env.PORT ?? 4000)
const HOST = process.env.HOST ?? '0.0.0.0'
const HTTPS_CERT_PATH = process.env.HTTPS_CERT_PATH
const HTTPS_KEY_PATH = process.env.HTTPS_KEY_PATH

// ðŸ”’ æ•°æ®åº“ä¿ç•™ç­–ç•¥é…ç½® / Database retention policy configuration
const DB_RETENTION_DAYS_SNAPSHOTS = Number.parseInt(
  process.env.DB_RETENTION_DAYS_SNAPSHOTS ?? '30',
  10,
) // é»˜è®¤ä¿ç•™ 30 å¤©å¿«ç…§ / Default 30 days snapshots
const DB_RETENTION_DAYS_ALERTS = Number.parseInt(
  process.env.DB_RETENTION_DAYS_ALERTS ?? '90',
  10,
) // é»˜è®¤ä¿ç•™ 90 å¤©è­¦æŠ¥ / Default 90 days alerts
const DB_RETENTION_DAYS_NOTIFICATION_FIXES = Number.parseInt(
  process.env.DB_RETENTION_DAYS_NOTIFICATION_FIXES ?? '30',
  10,
) // é»˜è®¤ä¿ç•™ 30 å¤©é€šçŸ¥æ—¥å¿— / Default 30 days notification logs
const DB_RETENTION_DAYS_MEMORIES = Number.parseInt(
  process.env.DB_RETENTION_DAYS_MEMORIES ?? '365',
  10,
) // é»˜è®¤ä¿ç•™ 365 å¤©è®°å¿† / Default 365 days memories
const DB_CLEANUP_INTERVAL_HOURS = Number.parseInt(
  process.env.DB_CLEANUP_INTERVAL_HOURS ?? '24',
  10,
) // é»˜è®¤æ¯ 24 å°æ—¶æ¸…ç†ä¸€æ¬¡ / Default cleanup every 24 hours

// ðŸ”’ æ•°æ®åº“æ¸…ç†å®šæ—¶ä»»åŠ¡ / Database cleanup scheduled task
function setupDatabaseCleanup() {
  const intervalMs = DB_CLEANUP_INTERVAL_HOURS * 60 * 60 * 1000

  // å»¶è¿Ÿ5ç§’åŽæ‰§è¡Œç¬¬ä¸€æ¬¡æ¸…ç†ï¼Œé¿å…é˜»å¡žå¯åŠ¨ / Delay first cleanup by 5s to avoid blocking startup
  setTimeout(() => {
    performCleanupTask()
  }, 5000)

  // è®¾ç½®å®šæ—¶ä»»åŠ¡ / Setup scheduled task
  setInterval(performCleanupTask, intervalMs)

  console.log(`[database] Cleanup scheduled every ${DB_CLEANUP_INTERVAL_HOURS} hours (first run in 5s)`)
  console.log(`[database] Retention: snapshots=${DB_RETENTION_DAYS_SNAPSHOTS}d, alerts=${DB_RETENTION_DAYS_ALERTS}d, notifications=${DB_RETENTION_DAYS_NOTIFICATION_FIXES}d, memories=${DB_RETENTION_DAYS_MEMORIES}d`)
}

function performCleanupTask() {
  try {
    const statsBefore = getDatabaseStats()
    console.log(
      `[database] Cleanup started: ${statsBefore.snapshotCount} snapshots, ${statsBefore.alertCount} alerts, ${statsBefore.databaseSizeKb}KB`,
    )

    const cleanupStats = performDatabaseCleanup({
      snapshotRetentionDays: DB_RETENTION_DAYS_SNAPSHOTS,
      alertRetentionDays: DB_RETENTION_DAYS_ALERTS,
      notificationFixRetentionDays: DB_RETENTION_DAYS_NOTIFICATION_FIXES,
      memoryRetentionDays: DB_RETENTION_DAYS_MEMORIES,
    })

    const statsAfter = getDatabaseStats()
    console.log(
      `[database] Cleanup completed: deleted ${cleanupStats.snapshotsDeleted} snapshots, ${cleanupStats.alertsDeleted} alerts, ${cleanupStats.notificationFixesDeleted} notifications, ${cleanupStats.memoriesDeleted} memories`,
    )
    console.log(`[database] After cleanup: ${statsAfter.snapshotCount} snapshots remaining, ${statsAfter.databaseSizeKb}KB`)
  } catch (error) {
    console.error('[database] Cleanup failed:', error)
  }
}

function logStartup(protocol: 'http' | 'https') {
  console.log(`Smart Cat backend listening on ${protocol}://${HOST}:${PORT}`)
  if (ALLOWED_ORIGINS.length > 0) {
    console.log(`CORS origins: ${ALLOWED_ORIGINS.join(', ')}`)
  } else {
    console.log('CORS: allowing all origins (development mode)')
  }
  console.log(`[tts] ${ENABLE_TTS ? `Enabled (model: ${TTS_MODEL_ID})` : 'Disabled via ENABLE_TTS'}`)
  console.log(`History retention: ${HISTORY_LIMIT} snapshots`)

  // ðŸ”’ å¯åŠ¨åŽè®¾ç½®æ•°æ®åº“æ¸…ç†ä»»åŠ¡ / Setup database cleanup after startup
  setupDatabaseCleanup()

  // ðŸ§  Initialize memory search cache
  rebuildMemorySearchCache()

  // ðŸš¨ Initialize alert manager
  initializeAlertManager({
    vapidPublicKey: VAPID_PUBLIC_KEY,
    vapidPrivateKey: VAPID_PRIVATE_KEY,
    vapidSubject: VAPID_CONTACT,
    deduplicationWindowMs: 5 * 60 * 1000, // 5 minutes
    alertHistoryLimit: ALERT_HISTORY_LIMIT,
  })

  // ðŸš€ Initialize Ultra Mode
  if (aiConfig.pro && aiConfig.standard) {
    initializeUltraManager(
      aiConfig.pro,       // Proé…ç½®
      aiConfig.standard,  // Standardé…ç½®
      {
        executeToolCall,
        buildToolResultPrompt,
        recordToolEvent,
        maxToolIterations: MAX_TOOL_CALL_ITERATIONS,
      },
    )
    console.log('[ultra] Dual-model collaborative system ready')
  } else {
    console.warn('[ultra] Skipped initialization: pro or standard model config missing.')
  }

  // ðŸ“ Initialize file upload directories
  fileHandler.ensureUploadDir().then(() => {
    console.log('[files] Upload directories initialized')
  }).catch((error) => {
    console.error('[files] Failed to initialize upload directories:', error)
  })

  // ðŸ’¡ Start proactive assistant
  proactiveAssistant.startProactiveAssistant()
  console.log('[proactive] Assistant started (checking every 15 minutes)')
}

if (HTTPS_CERT_PATH && HTTPS_KEY_PATH) {
  try {
    const key = fs.readFileSync(HTTPS_KEY_PATH)
    const cert = fs.readFileSync(HTTPS_CERT_PATH)
    https
      .createServer({ key, cert }, app)
      .listen(PORT, HOST, () => logStartup('https'))
  } catch (error) {
    console.error(
      '[https] Failed to initialise TLS; falling back to HTTP server.',
      error instanceof Error ? error.message : error,
    )
    app.listen(PORT, HOST, () => logStartup('http'))
  }
} else {
  app.listen(PORT, HOST, () => logStartup('http'))
}
