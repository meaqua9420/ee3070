// ğŸ”§ ESP8266 WiFi POST Fix Patch
// ä¿®å¤ cipsendFailed é”™è¯¯ / Fix cipsendFailed error

// ========================================
// æ–¹æ¡ˆ 1ï¼šå¢åŠ é‡è¯•æœºåˆ¶ï¼ˆæ¨èï¼‰
// ========================================

// åœ¨ esp8266HttpRequest å‡½æ•°ä¸­ï¼ˆline 2265 é™„è¿‘ï¼‰ï¼Œä¿®æ”¹å¦‚ä¸‹ï¼š

bool esp8266HttpRequest(const char* method, const String& path, const String& body, const char* contentType, int& statusCode, String& responseBody, String* rawResponseOut) {
  // ğŸ”§ æ·»åŠ é‡è¯•æœºåˆ¶ - æœ€å¤šé‡è¯• 2 æ¬¡
  const int MAX_RETRIES = 2;

  for (int retry = 0; retry <= MAX_RETRIES; retry++) {
    if (retry > 0) {
      Serial.print(F("{\"info\":\"retrying\",\"attempt\":"));
      Serial.print(retry + 1);
      Serial.println(F("}"));

      // ğŸ”§ é‡è¯•å‰æ¸…ç† ESP8266 ç¼“å†²åŒº
      esp8266SendCommand(F("AT+CIPCLOSE"), "OK", "ERROR", 1000);
      delay(500);  // å¢åŠ å»¶è¿Ÿ
      while (esp8266.available()) {
        esp8266.read();
      }
    }

    if (!wifiConnected && !esp8266EnsureWifi()) {
      if (retry < MAX_RETRIES) continue;  // ğŸ”§ é‡è¯•
      return false;
    }

    // ğŸ”§ ç¡®ä¿ä¹‹å‰çš„è¿æ¥å·²å…³é—­
    esp8266SendCommand(F("AT+CIPCLOSE"), "OK", "ERROR", 1000);
    delay(100);  // å¢åŠ å»¶è¿Ÿ

    char startCmd[64];
    snprintf(startCmd, sizeof(startCmd), "AT+CIPSTART=\"TCP\",\"%s\",%u", BACKEND_HOST, BACKEND_PORT);
    bool started = esp8266SendCommand(String(startCmd), "OK", "ALREADY CONNECTED", 10000);
    if (!started) {
      Serial.println(F("{\"error\":\"tcpConnectFailed\"}"));
      esp8266SendCommand(F("AT+CIPCLOSE"), "OK", nullptr, 1000);
      if (retry < MAX_RETRIES) continue;  // ğŸ”§ é‡è¯•
      return false;
    }

    // ğŸ”§ ç­‰å¾…è¿æ¥ç¨³å®š
    delay(200);

    String request;
    request.reserve(body.length() + 256);
    request += method;
    request += ' ';
    request += path;
    request += F(" HTTP/1.1\r\nHost: ");
    request += BACKEND_HOST;
    request += F("\r\nUser-Agent: SmartCatBridge/");
    request += F(FIRMWARE_VERSION);
    request += F("\r\nConnection: close");
    if (contentType && *contentType) {
      request += F("\r\nContent-Type: ");
      request += contentType;
    }
    if (strlen(BACKEND_API_KEY) > 0) {
      request += F("\r\nAuthorization: Bearer ");
      request += BACKEND_API_KEY;
    }
    if (body.length() > 0) {
      request += F("\r\nContent-Length: ");
      request += body.length();
    }
    request += F("\r\n\r\n");
    request += body;

    String sendCmd = String(F("AT+CIPSEND=")) + request.length();
    // ğŸ”§ å¢åŠ è¶…æ—¶æ—¶é—´ 3000 â†’ 5000ms
    if (!esp8266SendCommand(sendCmd, ">", nullptr, 5000)) {
      Serial.println(F("{\"error\":\"cipsendFailed\"}"));
      esp8266SendCommand(F("AT+CIPCLOSE"), "OK", nullptr, 1000);
      if (retry < MAX_RETRIES) continue;  // ğŸ”§ é‡è¯•
      return false;
    }

    esp8266.print(request);
    // ğŸ”§ å¢åŠ  SEND OK è¶…æ—¶ 10000 â†’ 15000ms
    bool sendOk = esp8266WaitFor("SEND OK", nullptr, 15000);

    // Capture entire response (all +IPD segments) until CLOSED token or extended idle
    String rawResponse;
    const unsigned long RESPONSE_IDLE_TIMEOUT_MS = 2500;
    const unsigned long RESPONSE_MAX_DURATION_MS = 9000;
    unsigned long lastByte = millis();
    unsigned long overallStart = lastByte;
    bool sawClosedToken = false;
    while ((millis() - overallStart) < RESPONSE_MAX_DURATION_MS) {
      bool dataRead = false;
      while (esp8266.available()) {
        char c = esp8266.read();
        lastByte = millis();
        dataRead = true;
        if (rawResponse.length() < ESP8266_HTTP_RESPONSE_MAX) {
          rawResponse += c;
        }
        const size_t len = rawResponse.length();
        if (len >= 6 &&
            rawResponse.charAt(len - 1) == 'D' &&
            rawResponse.charAt(len - 2) == 'E' &&
            rawResponse.charAt(len - 3) == 'S' &&
            rawResponse.charAt(len - 4) == 'O' &&
            rawResponse.charAt(len - 5) == 'L' &&
            rawResponse.charAt(len - 6) == 'C') {
          sawClosedToken = true;
          break;
        }
      }
      if (sawClosedToken) {
        break;
      }
      if (!dataRead && (millis() - lastByte) > RESPONSE_IDLE_TIMEOUT_MS) {
        break;
      }
    }

    esp8266SendCommand(F("AT+CIPCLOSE"), "OK", "ERROR", 1000, false);
    while (esp8266.available()) {
      esp8266.read();
    }

    if (rawResponseOut) {
      *rawResponseOut = rawResponse;
    }

    if (!sendOk && rawResponse.length() == 0) {
      Serial.println(F("{\"error\":\"httpNoResponse\"}"));
      if (retry < MAX_RETRIES) continue;  // ğŸ”§ é‡è¯•
      return false;
    }

    // ğŸ”§ å¦‚æœæˆåŠŸï¼Œè·³å‡ºé‡è¯•å¾ªç¯
    if (sendOk || rawResponse.length() > 0) {
      // ç»§ç»­è§£æå“åº”ï¼ˆåŸæœ‰ä»£ç ï¼‰
      // ... (åç»­ä»£ç ä¿æŒä¸å˜)
      return true;  // æš‚æ—¶è¿”å›ï¼Œå®é™…éœ€è¦ç»§ç»­è§£æå“åº”
    }
  }

  return false;  // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
}


// ========================================
// æ–¹æ¡ˆ 2ï¼šä¸´æ—¶åº”æ€¥æ–¹æ¡ˆï¼ˆå¦‚æœæ–¹æ¡ˆ1å¤ªå¤æ‚ï¼‰
// ========================================

// åªä¿®æ”¹è¶…æ—¶æ—¶é—´ï¼Œä¸æ·»åŠ é‡è¯•ï¼š

// Line 2307: è¶…æ—¶ 3000 â†’ 5000ms
if (!esp8266SendCommand(sendCmd, ">", nullptr, 5000)) {

// Line 2314: è¶…æ—¶ 10000 â†’ 15000ms
bool sendOk = esp8266WaitFor("SEND OK", nullptr, 15000);

// Line 2270: å¢åŠ å…³é—­å»¶è¿Ÿ 50 â†’ 200ms
delay(200);


// ========================================
// æ–¹æ¡ˆ 3ï¼šå®šæœŸæ¸…ç† ESP8266 ç¼“å†²åŒº
// ========================================

// åœ¨ loop() å‡½æ•°ä¸­æ·»åŠ å®šæœŸæ¸…ç†ï¼š

unsigned long lastEsp8266Cleanup = 0;
const unsigned long ESP8266_CLEANUP_INTERVAL = 60000;  // æ¯60ç§’

void loop() {
  unsigned long now = millis();

  // ... åŸæœ‰ä»£ç  ...

  #if ENABLE_ESP8266
  if (now - lastEsp8266Cleanup > ESP8266_CLEANUP_INTERVAL) {
    lastEsp8266Cleanup = now;
    // æ¸…ç† ESP8266 ç¼“å†²åŒº
    while (esp8266.available()) {
      esp8266.read();
    }
    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    esp8266SendCommand(F("AT+CIPSTATUS"), "OK", nullptr, 1000);
  }
  #endif

  // ... åŸæœ‰ä»£ç  ...
}
